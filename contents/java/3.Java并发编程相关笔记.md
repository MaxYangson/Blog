## 1. JAVA并发编程基础知识

**进程**：程序的一次执行过程。

**线程**：线程与进程相似，但线程是一个比进程更小的执行单位。

### 进程和线程的区别

- **地址空间**： 同一进程的所有线程共享本进程的地址空间，而不同的进程之间的地址空间是独立的。

- **资源拥有**： 同一进程的所有线程共享本进程的资源，如内存，CPU，IO、堆、方法区等。进程之间的资源是独立的，无法共享。每个线程拥有独立的栈空间和程序计数器。

- **执行过程**：每一个进程可以说就是一个可执行的应用程序，每一个独立的进程都有一个程序执行的入口，顺序执行序列。但是线程不能够独立执行，必须依存在应用程序中，由程序的多线程控制机制进行控制。

- **健壮性**： 因为同一进程的所有线程共享此线程的资源可能带来安全隐患（需要线程同步），且一个线程出现异常可能导致其他线程退出。 但是各个进程之间的资源是独立的，因此当一个进程崩溃时，不会影响其他进程。因此进程比线程健壮。

- **并发和资源消耗**：两者均可并发执行。进程切换时，消耗的资源大，效率低。所以涉及到频繁的切换时，使用线程要好于进程。如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程。

  > 进程是系统资源分配的基本单位，线程是CPU执行和调度的基本单位。

### 并发和并行

单核 cpu 下，线程实际还是 `串行执行` 的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是 `同时运行的` 。总结为一句话就是： **微观串行，宏观并行** ——同一时间段内应付多个任务

多核 cpu下，每个 `核（core）` 都可以调度运行线程，这时候线程可以是并行的——多核cpu同时执行多个任务

应用：

1）多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如 果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停... 

2）开启多个线程，充分利用多核 cpu 的优势，提高运行效率

注意：

1. 单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活 

2. 多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的 

- - 有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】） 
  - 也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义 

3. IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化

### 创建线程

#### 继承`Thread`类

继承`Thread`类并重写`run()`方法，创建`Thread`子类对象并调用`start()`方法启动线程（启动子线程并调用其`run()`方法）即可。

```java
// 创建线程对象
Thread t = new Thread() {
    public void run() {
        // 要执行的任务
    }
};
// 启动线程
t.start();

// 指定线程名字：构造方法的参数是给线程指定名字，推荐
Thread t1 = new Thread("t1") {
    @Override
    // run 方法内实现了要执行的任务
    public void run() {
        log.debug("hello");
    }
};
t1.start();

// 输出 `19:19:00 [t1] c.ThreadStarter - hello`
```



> join()方法可以阻塞当前线程, 把CPU控制权交给调用join()方法的线程直到它结束。
>
> sleep()方法可以让当前线程睡眠。
>
> yield()方法可以释放当前线程的CPU控制权。
>
> get/setPriority()方法可以获取或者设置线程的优先级（高优先级的不一定会被先执行完）。

- JAVA中只能单继承，不建议使用继承Thread的方法来实现。



#### 实现`Runable`接口

将实现`Runable`接口的类（重写其中的`run()`方法）的对象作为参数传入`Thread`构造方法中即可。【推荐此方法】：

- **可以避免Java中单继承的弊端**：利用接口来实现多继承的功能。
- **比较适用于多个线程共享数据的情况**（不需要把数据声明为static，直接在创建新线程时传入实现`Runbale`接口的类的同一个对象即可）。
- 把【线程】和【任务】（要执行的代码）分开 。Thread 代表线程 、Runnable 可运行的任务（线程要执行的代码）
  - 用 Runnable 更容易与线程池等高级 API 配合 
  - 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活

```java
Runnable runnable = new Runnable() {
    public void run(){
        // 要执行的任务
    }
};
// 创建线程对象
Thread t = new Thread( runnable );
// 启动线程
t.start();
```

```java
// 创建任务对象
Runnable task2 = new Runnable() {
    @Override
    public void run() {
        log.debug("hello");
    }
};

// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, "t2");
t2.start();
```

```java
// Java 8 以后可以使用 lambda 精简代码
Runnable task2 = () -> log.debug("hello");

// 参数1 是任务对象; 参数2 是线程名字，推荐
Thread t2 = new Thread(task2, "t2");
t2.start();
```

***** **原理之** **Thread** **与** **Runnable** **的关系** 

分析 Thread 的源码，理清它与 Runnable 的关系，Thread类的底层就是调用Runnable对象的

```java
private Runnable target; 
@Override
public void run() {
    if (target != null) {
        target.run();
    }
}
```



#### 实现`Callable`接口

JDK5.0中新增的方式，实现`Callable`接口并重写`call()`方法即可。功能更加强大：支持返回值（需要借助`FutureTask`类）、泛型、抛出异常。

具体实现举例：

```java
class CallableCalculate implements Callable<Integer> {
    // 回调函数
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i < 100; i++) {
            sum += i;
        }
        return sum;
    }
}

public class CallableThread {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        CallableCalculate calculate = new CallableCalculate();
        FutureTask<Integer> task = new FutureTask<Integer>(calculate);
        Thread thread = new Thread(task);
        thread.start();
        // 获取线程返回值并输出
        System.out.println(task.get());
    }
}
```

```java
// 采用lamda形式
FutureTask<Integer> task3 = new FutureTask<>(() -> {
    log.debug("hello");
    return 100;
});   // 传入的是：实现callable接口的类

// 参数1 是任务对象; 参数2 是线程名字，推荐
new Thread(task3, "t3").start();

// 主线程阻塞，同步等待 task 执行完毕的结果
Integer result = task3.get();
log.debug("结果是:{}", result);
```

输出

```plain
19:22:27 [t3] c.ThreadStarter - hello
19:22:27 [main] c.ThreadStarter - 结果是:100
```



#### 使用线程池【推荐】

JDK1.5中的新特性，提前创建好多个线程放入线程池中，使用时直接获取用完重新放入线程池，可以避免频繁创建和销毁线程，实现重复利用，提升性能。



### 线程运行和切换

栈与栈帧——Java 虚拟机栈

我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。 

- 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 
- 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 

线程上下文切换（Thread Context Switch）原因：

- 线程的 cpu 时间片用完 
- 垃圾回收 
- 有更高优先级的线程需要运行 
- 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 

当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 

- 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 
- Context Switch 频繁发生会影响性能



### 线程常见方法

<img src="assets/image-20220923163833846.png" alt="image-20220923163833846" style="zoom:67%;" />

<img src="assets/image-20220923163946373.png" alt="image-20220923163946373" style="zoom:67%;" />

<img src="assets/image-20220923164017265.png" alt="image-20220923164017265" style="zoom:67%;" />

#### start 与 run

- 直接调用 run 是在主线程中执行了 run，没有启动新的线程 
- 使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码

#### sleep 与 yield

——用于让出cpu使用权，避免cpu空转

sleep

- 1. 调用 sleep 会让当前线程从 *Running*进入 *Timed Waiting* 状态（阻塞） 
- 2. 其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 
- 3. 睡眠结束后的线程未必会立刻得到执行 
- 4. 建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 

yield

- 1. 调用 yield 会让当前线程从 *Running* 进入 *Runnable*就绪状态，然后调度cpu执行其它线程，但是还有可能立马调度到当前线程
- 2. 具体的实现依赖于操作系统的任务调度器 

线程优先级

- 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 
- 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用

```java
Runnable task1 = () -> {
    int count = 0;
    for (;;) {
        System.out.println("---->1 " + count++);
    }
};
Runnable task2 = () -> {
    int count = 0;
    for (;;) {
        // Thread.yield();
        System.out.println(" ---->2 " + count++);
    }
};
Thread t1 = new Thread(task1, "t1");
Thread t2 = new Thread(task2, "t2");
// t1.setPriority(Thread.MIN_PRIORITY);
// t2.setPriority(Thread.MAX_PRIORITY);
t1.start();
t2.start();
```

##### 应用: 让出对CPU的使用

1）sleep 实现——不需要加锁

在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权 给其他程序

```java
while(true) {
    try {
        Thread.sleep(50);   // 线程自身执行sleep方法
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

2）wait 或 条件变量实现——需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景 

```java
// wait实现
synchronized(锁对象) {
    while(条件不满足) {
        try {
            锁对象.wait();   // 锁对象执行wait方法
        } catch(InterruptedException e) {
            e.printStackTrace();
        }
    }
    // do sth...
}

// 条件变量实现
lock.lock();
try {
    while(条件不满足) {
        try {
            条件变量.await();   // 条件变量执行await方法
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    // do sth...
} finally {
    lock.unlock();
}
```



#### join方法

——用于主线程和子线程之间的同步，等待子线程执行结束

```java
// 用于主线程和子线程的同步
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
    test2();
}
private static void test2() throws InterruptedException {
    Thread t1 = new Thread(() -> {
        sleep(1);
        r1 = 10;
    });
    Thread t2 = new Thread(() -> {
        sleep(2);
        r2 = 20;
    });
    long start = System.currentTimeMillis();
    t1.start();
    t2.start();
    t1.join();
    t2.join();
    long end = System.currentTimeMillis();
    log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}
// 20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005

// 有时效的join
static int r1 = 0;
static int r2 = 0;
public static void main(String[] args) throws InterruptedException {
    test3();
}
public static void test3() throws InterruptedException {
    Thread t1 = new Thread(() -> {
        sleep(1);
        r1 = 10;
    });
    long start = System.currentTimeMillis();
    t1.start();
    // 线程执行结束会导致 join 结束
    t1.join(1500);       // r1 = 10;
    // 没等够时间的话，直接返回未处理值
    // t1.join(500);     // r1 = 0
    long end = System.currentTimeMillis();
    log.debug("r1: {} r2: {} cost: {}", r1, r2, end - start);
}
```



### 线程中断/停止/退出

####  interrupt (中断)

——实际上是Java中对线程[中断](https://so.csdn.net/so/search?q=中断&spm=1001.2101.3001.7020)机制的实现

在以前的jdk版本中，我们使用stop方法中断线程，但是现在的jdk版本中已经不再推荐使用该方法了，反而由以下三个方法完成对线程中断的支持。

```java
// 中断是线程的一个标识属性（线程启动时该标志位默认`false`），通过这三个函数实现线程中断
public boolean isInterrupted()   // 判断是否被打断，返回线程中断状态，不会清除打断标记
public void interrupt()         // 返回中断标志且设置标志位为true
public static boolean interrupted()  // 判断是否被打断，返回线程中断状态，同时会清除打断标记
```

> 注意：`interrupt()` 方法并不能立即中断线程，该方法仅仅告诉线程外部已经有中断请求，至于是否中断还取决于这个线程对中断标志位为true的处理。

说明：

**interrupt() 它基于「一个线程不应该由其他线程来强制中断或停止，而是应该由线程自己自行停止。」思想，是一个比较温柔的做法，它更类似一个标志位。**

**其实作用不是中断线程，而是「通知线程应该中断了」，具体到底中断还是继续运行，应该由被通知的线程自己处理。**

**interrupt() 并不能真正的中断线程，这点要谨记。**

类型：

1）打断阻塞态的线程（ sleep，wait，join）， 会抛出打断异常（java.lang.InterruptedException），同时清空打断状态（为false），以 sleep 为例

```java
private static void test1() throws InterruptedException {
    Thread t1 = new Thread(()->{
        sleep(1);
    }, "t1");
    t1.start();
    sleep(0.5);
    t1.interrupt();   // 打断t1线程
    log.debug(" 打断状态: {}", t1.isInterrupted());
}
```

输出

```java
java.lang.InterruptedException: sleep interrupted
     at java.lang.Thread.sleep(Native Method)
     at java.lang.Thread.sleep(Thread.java:340)
     at java.util.concurrent.TimeUnit.sleep(TimeUnit.java:386)
     at cn.itcast.n2.util.Sleeper.sleep(Sleeper.java:8)
     at cn.itcast.n4.TestInterrupt.lambda$test1$3(TestInterrupt.java:59)
     at java.lang.Thread.run(Thread.java:745)
21:18:10.374 [main] c.TestInterrupt - 打断状态: false
```



2）打断正常运行的线程, 会设置打断标记（设置为true），此时需要在当前线程中利用`isInterrupted()`方法时刻检测当前线程是否被中断，以做进一步中断处理：

```java
private static void test2() throws InterruptedException {
    Thread t2 = new Thread(()->{
        while(true) {
            Thread current = Thread.currentThread();
            boolean interrupted = current.isInterrupted();
            if(interrupted) {
                log.debug(" 打断状态: {}", interrupted);
                break;
            }
        }
    }, "t2");
    t2.start();
    sleep(0.5);
    t2.interrupt();
}
```

输出

```
20:57:37.964 [t2] c.TestInterrupt - 打断状态: true 
```



测试代码如下：

```java
public class InterruptTest {
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(new InterruptThread());
        thread.start();
        Thread.sleep(1000);
        System.out.println("main() interrupt thread!");
        thread.interrupt();
        System.out.println("main() finished!");
    }
}

class InterruptThread implements Runnable {
    public void run() {
        try {
            while (true) {
                // 获取线程中断标志位
                System.out.println("Begin to run! isInterrupted:" + Thread.interrupted());
                // 休眠（阻塞方法）
                Thread.sleep(2000);
            }
        } catch (InterruptedException e) {
            // 抛出InterruptedException时线程的中断标志位会被自动设置成false
            System.out.println("Catch InterruptedException! isInterrupted:" + Thread.currentThread().isInterrupted());
            // 第二次中断本线程，自己调用中断自己
            Thread.currentThread().interrupt();
            System.out.println("isInterrupted:" + Thread.interrupted());  // 返回并重置
            System.out.println("isInterrupted:" + Thread.currentThread().isInterrupted());
            System.out.println("isInterrupted:" + Thread.interrupted());  // 返回并重置
            System.out.println("isInterrupted:" + Thread.currentThread().isInterrupted());
        }
    }
}

// ----- 打印输出 -----
/*
Begin to run! isInterrupted:false
main() interrupt thread!
main() finished!
Catch InterruptedException! isInterrupted:false
isInterrupted:true
isInterrupted:false
isInterrupted:false
isInterrupted:false
*/
```

阻塞和中断的关系

- 阻塞表示线程的一种状态，在这种状态下，线程是不占用CPU的（也就是说，不执行你写的命令代码的），更进一步来说，也就是你的代码在执行过程中，在某个地方暂停了。
- 而中断最初的含义是，指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。但在java中，**中断的作用明显被弱化了**，中断更多的是指线程标志位的某个状态，而**中断的处理逻辑需要用户自己来进行定制（你可以选择处理中断，也可以选择不处理），责任交给了用户。**
  ——总结：java使用中断标志位和上述三个函数，实际上实现的是一种程序员自己能够处理`外界中断`的机制

中断处理方案：

+ 如果被中断线程是非阻塞状态，则执行该线程内部对于中断标志位为true的处理方案；
+ 如果被中断线程是阻塞状态，则执行打断的时候被中断线程会抛出`InterruptException`异常，同时JVM会使该线程离开阻塞状态，然后该线程就可以获得cpu，从而执行对该异常的处理

> 当Java的某个线程处于可中断的阻塞状态时，你用另一个线程调用该线程的interrupt()方法时，JVM会使该线程离开阻塞状态，并抛出一个异常。既然该线程已经离开阻塞状态，自然要参与到对CPU时间的争夺中，当获取到CPU时间时自然可以处理该异常。

#### 安全地终止线程

——采用两阶段终止模式

在一个线程 T1 中如何“优雅”终止线程 T2？这里的【优雅】指的是给 T2 一个料理后事的机会。 

1）错误思路

- 使用线程对象的 stop() 方法停止线程 ——stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁 

- 使用 System.exit(int) 方法停止线程 ——目的仅是停止一个线程，但这种做法会让整个程序都停止

- suspend()/resume()/stop()用来暂停/恢复/终止线程，但是这三个方法不安全！已经被弃用！可以使用wait()/notify()机制来替代。

  suspend()可能引发死锁！stop()无法及时释放资源！—— 这些方法已过时，容易破坏同步代码块，造成线程死锁

2）解决方案：采用两阶段终止模式

<img src="assets/image-20220924103454851.png" alt="image-20220924103454851" style="zoom:50%;" />

具体实现：可以使用一个布尔变量或者利用中断（本质上也是一个布尔变量，只不过是JAVA中线程自带的，并且在线程相关的API中都会检查这个中断变量）来判断线程是否需要退出

**利用 isInterrupted**：interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行

```java
class TPTInterrupt {
    private Thread thread;
    public void start(){
        thread = new Thread(() -> {
            while(true) {
                Thread current = Thread.currentThread();
                if(current.isInterrupted()) {   // 如果正常运行，收到外面主线程的中断，则执行下面的程序料理后事
                    log.debug("料理后事");
                    break;
                }
                try {
                    Thread.sleep(1000);
                    log.debug("将结果保存");
                } catch (InterruptedException e) {  // 如果在sleep，wait，join时被中断，则执行下面的
                    current.interrupt();
                }
                // 执行监控操作 
            }
        },"监控线程");
        thread.start();
    }
    public void stop() {
        thread.interrupt();
    }
}
```

调用

```java
TPTInterrupt t = new TPTInterrupt();
t.start();

Thread.sleep(3500);
log.debug("stop");
t.stop();
```

结果

```java
11:49:42.915 c.TwoPhaseTermination [监控线程] - 将结果保存
11:49:43.919 c.TwoPhaseTermination [监控线程] - 将结果保存
11:49:44.919 c.TwoPhaseTermination [监控线程] - 将结果保存
11:49:45.413 c.TestTwoPhaseTermination [main] - stop 
11:49:45.413 c.TwoPhaseTermination [监控线程] - 料理后事
```

**利用停止标记**

```java
// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性
// 我们的例子中，即主线程把它修改为 true 对 t1 线程可见
class TPTVolatile {
    private Thread thread;
    private volatile boolean stop = false;

    public void start(){
        thread = new Thread(() -> {
            while(true) {
                //Thread current = Thread.currentThread();
                if(stop) {
                    log.debug("料理后事");
                    break;
                }
                try {
                    Thread.sleep(1000);
                    log.debug("将结果保存");
                } catch (InterruptedException e) {
					stop = true;
                }
                // 执行监控操作
            }
        },"监控线程");
        thread.start();
    }
    public void stop() {
        stop = true;
        thread.interrupt();
    }
}
```

调用 

```java
TPTVolatile t = new TPTVolatile();
t.start();

Thread.sleep(3500);
log.debug("stop");
t.stop();
```

结果

```java
11:54:52.003 c.TPTVolatile [监控线程] - 将结果保存
11:54:53.006 c.TPTVolatile [监控线程] - 将结果保存
11:54:54.007 c.TPTVolatile [监控线程] - 将结果保存
11:54:54.502 c.TestTwoPhaseTermination [main] - stop 
11:54:54.502 c.TPTVolatile [监控线程] - 料理后事
```



或者采用下面的代码模式：

```java
// 测试代码
public class SafeStopTest {
    public static void main(String[] args) throws InterruptedException {
        MyThread r1 = new MyThread();
        Thread t1 = new Thread(r1, "线程1");
        Thread t2 = new Thread(new MyThread(), "线程2");
        t1.start();
        t2.start();
        Thread.sleep(1000);
        r1.cancel();
        Thread.sleep(1100);
        t2.interrupt();
    }
}

class MyThread implements Runnable {
    private volatile boolean stop = false;

    private static int count = 0;

    public void run() {
        while (!stop && !Thread.currentThread().isInterrupted()) {
            synchronized (MyThread.class) {
                count++;
                System.out.println(Thread.currentThread().getName() + "正在执行任务, count = " + count);	// 注意输出部分也要保证在同步代码块里面！
            }
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                System.out.println(Thread.currentThread().getName() + "收到中断信号");
                break;
            }
        }
        // 此处可以做释放资源等操作
        System.out.println(Thread.currentThread().getName() +  "安全退出！count = " + count);
    }

    public void cancel() {
        System.out.println(Thread.currentThread().getName() + "调用Cancel()方法");
        stop = true;
    }
}

// ----- 输出打印 -----
/*
线程1正在执行任务, count = 1
线程2正在执行任务, count = 2
线程2正在执行任务, count = 3
线程1正在执行任务, count = 4
线程2正在执行任务, count = 5
线程1正在执行任务, count = 6
main调用Cancel()方法
线程1安全退出！count = 6
线程2正在执行任务, count = 7
线程2正在执行任务, count = 8
线程2收到中断信号
线程2安全退出！count = 8
*/
```

#### 打断 park 线程

打断 park 线程（暂停线程）, 也会设置打断标记（设置为true）

```java
private static void test3() throws InterruptedException {
    Thread t1 = new Thread(() -> {
        log.debug("park...");
        LockSupport.park();
        log.debug("unpark...");
        log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
    }, "t1");
    t1.start();
    sleep(0.5);
    t1.interrupt();
}
```

输出

```java
21:11:52.795 [t1] c.TestInterrupt - park... 
21:11:53.295 [t1] c.TestInterrupt - unpark... 
21:11:53.295 [t1] c.TestInterrupt - 打断状态：true
```

如果打断标记已经是 true, 则 park 会失效

```java
private static void test4() {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 5; i++) {
            log.debug("park...");
            LockSupport.park();
            log.debug("打断状态：{}", Thread.currentThread().isInterrupted());
        }
    });
    t1.start();
    sleep(1);
    t1.interrupt();
}
```

输出

```java
21:13:48.783 [Thread-0] c.TestInterrupt - park... 
21:13:49.809 [Thread-0] c.TestInterrupt - 打断状态：true 
21:13:49.812 [Thread-0] c.TestInterrupt - park... 
21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true 
21:13:49.813 [Thread-0] c.TestInterrupt - park... 
21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true 
21:13:49.813 [Thread-0] c.TestInterrupt - park... 
21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true 
21:13:49.813 [Thread-0] c.TestInterrupt - park... 
21:13:49.813 [Thread-0] c.TestInterrupt - 打断状态：true
```

提示：可以使用 Thread.interrupted() 清除打断状态

### 主线程与守护线程

默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 

例

```java
log.debug("开始运行...");
Thread t1 = new Thread(() -> {
log.debug("开始运行...");
sleep(2);
log.debug("运行结束...");
}, "daemon");
// 设置该线程为守护线程
t1.setDaemon(true);
t1.start();

sleep(1);
log.debug("运行结束...");
```

输出

```java
08:26:38.123 [main] c.TestDaemon - 开始运行... 
08:26:38.213 [daemon] c.TestDaemon - 开始运行... 
08:26:39.215 [main] c.TestDaemon - 运行结束...
```

**注意** 

- 垃圾回收器线程就是一种守护线程 
- Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等待它们处理完当前请求 



### 线程的生命周期*

线程的生命周期包含5个阶段，包括：新建、就绪、运行（包括ready、running）、阻塞（包括阻塞、waiting、timed_waiting）、销毁。各状态之间的转换图如下所示：

![image-20201023112046554](images/image-20201023112046554.png)

- **新建（New）**：就是刚使用new方法，new出来的线程，创建后尚未启动。

- **就绪（Runable）**

  - Ready：就是调用的线程的start()方法后，这时候线程处于等待CPU分配资源阶段，谁先获取到CPU资源，谁开始执行。

  - Running：当就绪的线程被调度并获得CPU资源时，便进入运行状态，run方法定义了线程的操作和功能。

- **阻塞（Blocked）**：请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以处于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。

- **无限期等待（WAITING）**：等待其它线程显式地唤醒。阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。

  | 进入方法                                   | 退出方法                             |
  | ------------------------------------------ | ------------------------------------ |
  | 没有设置 Timeout 参数的 Object.wait() 方法 | Object.notify() / Object.notifyAll() |
  | 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执行完毕                 |
  | LockSupport.park() 方法                    | LockSupport.unpark(Thread)           |

- **限期等待（TIMED_WAITING）**：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。

  | 进入方法                                     | 退出方法                                        |
  | -------------------------------------------- | ----------------------------------------------- |
  | Thread.sleep(long) 方法                      | 时间结束                                        |
  | 设置了 Timeout 参数的 Object.wait(long) 方法 | 时间结束 / Object.notify() / Object.notifyAll() |
  | 设置了 Timeout 参数的 Thread.join(long) 方法 | 时间结束 / 被调用的线程执行完毕                 |
  | LockSupport.parkNanos() 方法                 | LockSupport.unpark(Thread)                      |
  | LockSupport.parkUntil() 方法                 | LockSupport.unpark(Thread)                      |

  调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。

- **销毁（Terminated）**：如果线程正常执行完毕后或线程被提前强制性的终止或出现异常导致结束，那么线程就要被销毁，释放资源;

> park()相关方法内部调用了`sun.misc.Unsafe UNSAFE`类的方法，该类可以获取最高权限！



线程状态转换概览图

![img](assets/1649488969695-f0ed2e00-cc4c-4533-b658-208be7bab08d.png)

假设有线程 `Thread t`

**情况1 NEW --> RUNNABLE**

当调用 t.start() 方法时，由 NEW --> RUNNABLE

**情况2 RUNNABLE <--> WAITING**

**t 线程**用 `synchronized(obj)` 获取了对象锁后 

- 调用 obj.wait() 方法时，**t 线程**从 RUNNABLE --> WAITING 

- 调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 

- - 竞争锁成功，**t 线程**从WAITING --> RUNNABLE 
  - 竞争锁失败，**t 线程**从WAITING --> BLOCKED

```java
public class TestWaitNotify {
    final static Object obj = new Object();

    public static void main(String[] args) {

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行....");
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...."); // 断点
            }
        },"t1").start();

        new Thread(() -> {
            synchronized (obj) {
                log.debug("执行....");
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                log.debug("其它代码...."); // 断点
            }
        },"t2").start();

        sleep(0.5);
        log.debug("唤醒 obj 上其它线程");
        synchronized (obj) {
            obj.notifyAll(); // 唤醒obj上所有等待线程 断点
        }

    }
}
```

**情况 3 RUNNABLE <--> WAITING**

- **当前线程**调用 t.join() 方法时，**当前线程**从 RUNNABLE --> WAITING 

- - 注意是**当前线程**在**t 线程对象**的监视器上等待 

- **t 线程**运行结束，或调用了**当前线程**的 interrupt() 时，**当前线程**从 WAITING --> RUNNABLE

**情况 4 RUNNABLE <--> WAITING**

- 当前线程调用 LockSupport.park() 方法会让当前线程从 RUNNABLE --> WAITING 
- 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，会让目标线程从 WAITING -->RUNNABLE 

**情况 5 RUNNABLE <--> TIMED_WAITING**

**t** **线程**用 synchronized(obj) 获取了对象锁后 

- 调用 obj.wait(long n) 方法时，**t 线程**从 RUNNABLE --> TIMED_WAITING 
- **t 线程**等待时间超过了 n 毫秒，或调用 obj.notify() ， obj.notifyAll() ， t.interrupt() 时 
- - 竞争锁成功，**t 线程**从TIMED_WAITING --> RUNNABLE 
  - 竞争锁失败，**t 线程**从TIMED_WAITING --> BLOCKED

**情况 6 RUNNABLE <--> TIMED_WAITING**

- **当前线程**调用 t.join(long n) 方法时，**当前线程**从 RUNNABLE --> TIMED_WAITING 

- - 注意是**当前线程**在**t 线程对象**的监视器上等待 

- **当前线程**等待时间超过了 n 毫秒，或**t 线程**运行结束，或调用了**当前线程**的 interrupt() 时，**当前线程**从 TIMED_WAITING --> RUNNABLE

**情况 7 RUNNABLE <--> TIMED_WAITING**

- 当前线程调用 Thread.sleep(long n) ，当前线程从 RUNNABLE --> TIMED_WAITING 
- **当前线程**等待时间超过了 n 毫秒，**当前线程**从TIMED_WAITING --> RUNNABLE

**情况 8 RUNNABLE <--> TIMED_WAITING**

- 当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，**当前线 程**从 RUNNABLE --> TIMED_WAITING 
- 调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 TIMED_WAITING--> RUNNABLE

**情况 9 RUNNABLE <--> BLOCKED**

- **t 线程**用synchronized(obj) 获取对象锁时如果竞争失败，从RUNNABLE --> BLOCKED 
- 持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 BLOCKED的线程重新竞争，如果其中 **t 线程**竞争 成功，从 BLOCKED --> RUNNABLE ，其它失败的线程仍然BLOCKED 

**情况 10 RUNNABLE --> TERMINATED**

当前线程所有代码运行完毕，进入 TERMINATED 





### 解决线程安全问题

多个线程之间如果存在共享数据，则可能存在线程安全问题。

<font color="red">造成线程安全问题的根本原因：</font>

- **共享变量的可见性**：每个JAVA线程都有一个工作内存（缓存），线程直接读写工作内存，工作内存和主内存打交道；当写入工作内存的共享变量没有及时刷新到主内存，或当前工作内存中的数据是以前缓存的数据而不是当前主内存中最新的数据；会导致多个线程读取的同一共享变量的值是不一致的。
- **线程执行操作的原子性**：对共享变量的修改操作可能被其它线程打断，其它线程也可能对这个变量进行操作，所以导致线程不安全。

#### 1.5.1 同步代码块

给代码块加锁（所有线程共用同一个锁，任何一个对象都可以充当锁），需要传入一个监视器对象/锁（Obj），通常可以使用 **类名.class**。

```java
synchronized (Object obj) {	// obj是一个锁/监视器，多个线程必须共享一个obj，可以直接使用ClassName.class(因为在类加载时，会在堆中自动创建一个该类对应的对象)
    // 存在共享数据的代码块
    // ...
}
```

#### 1.5.2 同步方法

直接在方法返回类型前面加上`synchronized`关键字即可，此时监视器对象/锁默认为`this`对象（如果是静态方法则为当前类本身）。

```java
// 静态方法的同步监视器是当前类本身
public static synchronized void test1 () {
    // 方法中的代码块
    // ...
}

// 非静态方法的同步监视器是this
public synchronized void test2 () {
    // 方法中的代码块
    // ...
}
```

注意以下几点：

- 通过加锁可以实现线程安全，但是也会降低程序运行效率。

- 使用`synchronized`需要传入(显示或者隐式)一个同步锁，多个线程共用一个锁才能实现对共享数据的互斥访问。

- **线程死锁**：不同线程都在占用对方需要的资源不放弃，都在等待对方放弃需要的同步资源，形成无限阻塞即死锁（需要尽量避免嵌套定义同步代码快）。示例代码如下所示：

  ```java
  public class BlockTest {
      public static void main(String[] args) throws InterruptedException {
          final StringBuilder sb1 = new StringBuilder("test1");
          final StringBuilder sb2 = new StringBuilder("test2");
          
          new Thread() {
              @Override
              public void run() {
                  // 等待sb1锁
                  synchronized (sb1) {
                      sb1.append("-thread1");
  
                      try {
                          Thread.sleep(100);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
  
                      // 等待sb2锁
                      synchronized (sb2) {
                          sb2.append("-thread1");
                      }
                  }
              }
          }.start();
  
          new Thread(new Runnable() {
              public void run() {
                  // 等待sb2锁
                  synchronized (sb2) {
                      sb2.append("-thread2");
  
                      try {
                          Thread.sleep(100);
                      } catch (InterruptedException e) {
                          e.printStackTrace();
                      }
  
                      // 等待sb1锁
                      synchronized (sb1) {
                          sb1.append("-thread2");
                      }
                  }
              }
          }) {
          }.start();
  
          Thread.sleep(1000);
          System.out.println("sb1:" + sb1 + "\nsb2:" + sb2);
      }
  }
  
  // --- 最终造成死锁 ---
  // 输出打印（主线程未退出）
  /*
  sb1:test1-thread1
  sb2:test2-thread2
  */
  ```

产生思索的四个条件：

- 互斥条件：该资源任意一个时刻只由一个线程占用。

- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

- 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。

- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

#### 1.5.3 Lock锁

JDK1.5新增的特性，手动构造一个Lock对象（可以是公平锁也开始是非公平，如果是公平锁则使用该锁的线程可以公平地获取到CPU的执行权）并使用该对象的`lock()`和`unlock()`方法对代码块进行加锁和解锁。示例代码如下所示：

```java
class ServiceWindow implements Runnable {
    private int ticketNum = 100;
    // 创建一个公平锁
    private ReentrantLock lock = new ReentrantLock();

    public void run() {
        while (true) {
            lock.lock();	// lock()必须紧跟try代码块
            try {
                if (ticketNum > 0) {
                    System.out.println(Thread.currentThread().getName() + "：售票" + ticketNum);
                    try {
                        Thread.sleep(50);	// 为了增大线程切换的概率
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    ticketNum--;    // 非原子操作
                } else {
                    System.out.println(Thread.currentThread().getName() + "：票已售罄！");
                    break;
                }
            } finally {
                lock.unlock();
            }
        }
    }
}

public class LockTest {
    public static void main(String[] args) {
        ServiceWindow window = new ServiceWindow();
        Thread t1 = new Thread(window);
        Thread t2 = new Thread(window);
        Thread t3 = new Thread(window);
        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");
        t1.start();
        t2.start();
        t3.start();
    }
}

// 输出打印
/*
依次输出窗口1/2/3售票直到售罄。
*/
```

Lock锁和`synchronized`的区别：

- Lock锁需要手动加锁和释放锁，相对灵活
- 使用同步代码块/方法的方式需要传入监视器对象/锁，自动加锁/释放锁。

> 建议使用优先级 Lock锁 --> 同步代码块 --> 同步方法

#### 1.5.4 ThreadLocal

通常情况下，多线程访问统一共享变量容易出现并发问题，特别是在多个线程需要对一个共享变量进行写入时，为了安全需要做同步（加锁）。

`ThreadLocal`可以为线程提供本地变量，每个线程有一个`ThreadLocal`变量的本地副本，互不干扰，实现了**线程之间的数据隔离**。具体如下图所示：

![image-20210525165256227](images/image-20210525165256227.png)

 

一般使用`set()/get()/remove()`接口来设置/获取/移除变量值。使用举例：

```java
public class Main {
    private static ThreadLocal<String> localVar = new ThreadLocal<>();	// 所有线程共享访问，但是都有自身的副本

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                localVar.set("Thread1.localVar");
                print("Thread1");
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                // localVar.set("Thread2.localVar");
                print("Thread2");
            }
        }).start();
    }

    private static void print(String str) {
        System.out.println(str + ":" + localVar.get());
        // localVar.remove();	// 移除变量值
    }
}

// ------ 输出打印 -------
Thread1:Thread1.localVar
Thread2:null	// 说明线程2读取不到线程1的ThreadLocal变量值
```

##### 使用场景

> Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的**数据隔离**。

- **数据隔离**：每个请求处理线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程关了 B线程正在使用的 Connection，以及事务操作混乱问题。

- **数据传递**：比如在处理一个HTTP请求时，需要调用很多方法（比如Service层，DAO层等），每个方法都需要用到用户id、Token等信息，为了避免参数频繁传递，则可以将参数写入ThreadLocal变量中进行共享（只在单个线程中共享，因为处理一个请求的往往都是同一线程）。还经常用在全链路Trace跟踪等场景中。

##### 原理

事实上，`ThreadLocal`只是一个外壳，它内部会读写`Thread`实例中的`ThreadLocalMap threadLocals `成员变量（类似HashMap，key为`TreadLocal`变量，value为`ThreadLocal`变量中`set()`进去的值，使用**线性探测法解决哈希冲突**而不是拉链法）。

> 一个线程中可以存多个TreadLocal变量！最终的ThreadLocal变量值是存储在Thread中的！

![image-20210525165325215](images/image-20210525165325215.png)

```java
class ThreadLocalMap {
	public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }

    public void set(T value) {
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    }

    public void remove() {
        ThreadLocalMap m = getMap(Thread.currentThread());
        if (m != null)
            m.remove(this);
    }

    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
    void createMap(Thread t, T firstValue) {
        t.threadLocals = new ThreadLocalMap(this, firstValue);
    }    
}


```

##### 内存泄漏问题

```java
class ThreadLocalMap {
    private Entry[] table;	// 存储ThreadLocal变量和对应的值(哈希表, 线性探测法/开放地址法)
    
    static class Entry extends WeakReference<ThreadLocal<?>> {
        Object value;
        Entry(ThreadLocal<?> k, Object v) {
            super(k);
            value = v;
        }
    }
}
```

哈希表中的节点是继承了弱引用，而且key直接是交给了父类处理`super(key)`，父类是个弱引用，所以key是弱引用，key完全不存在内存泄漏问题，因为他不是强引用，它可以被GC回收的。

![image-20210319210124085](images/image-20210319210124085.png)

<span style = "color:red">**`ThreadLocalMap` 中使用的 key 为 `ThreadLocal` 的弱引用，而 value 是强引用。**</span>

比如在 **线程池** 这种场景下，**线程池的存在核心线程是不会销毁的**，只要创建出来他会反复利用，生命周期不会结束掉，**但是key是弱引用会被GC回收掉，value强引用不会回收**，所以形成了如下场面：

```java
Thread -> ThreadLocalMap -> Entry(key为null) -> value  //存在这种引用链
```

由于value和Thread还存在链路关系，还是可达的，所以不会被回收，这样越来越多的垃圾对象产生却无法回收，造成内存泄漏，时间久了必定OOM。

解决方案`ThreadLocal`已经为我们想好了，**提供了`remove()`方法**，这个方法是将value移出去的。所以用完后记得`remove()`（在调用`set()/get()`方法时也会把扫描到的key已经为null的value回收，在一定程度上也可以缓解内存泄漏问题）。

### 线程间通信

#### 1.6.1 `volatile`和`synchronized`

`volatile`和`synchronized`本质上也是一种线程间通信的机制！

以`synchronized`为例，当一个线程A获取到同步锁，则其它想要执行同步代码块/方法的线程将进入 **同步队列/锁池** 中（处于BLOCKED状态），直到线程A退出同步代码块/方法，释放同步锁，此时同步队列中的 **所有线程** 将出队并开始竞争同步锁，未竞争到同步锁的线程将继续进入同步队列。

![image-20201015001140435](images/image-20201015001140435.png)

#### 1.6.2 `wait()`等待/`notify()`通知机制

使用`wait()`和`notify()`/`notifyAll()`方法是任意Java对象都具备的功能。

- 调用`wait()`方法的线程将从RUNABLE进入WAITING状态（如果是调用带时间参数的`wait(long)`，线程将进入TIME_WAITING状态），同时释放同步锁，当前线程将进入**等待队列/等待池**中。一般该方法的调用会放在while语句中。
- 调用`notify()/notifyAll()`方法的线程将从WAITING/TIME_WAITING状态进入RUNNABLE状态（如果竞争到锁）/BLOCKED状态（如果未竞争到锁），一个/所有线程将从**等待队列/等待池中进入同步队列/锁池**中，等待别的线程释放当前的同步锁，一旦竞争到同步锁则由CPU调度执行。一般调用该方法的同时会修改让wait()调用执行的while循环条件。

**<font color="red">上述三个方法的调用者必须是同步代码块中的同一个监视器对象/同步锁</font>**（相当于共用一个信号量），否则将出现`java.lang.IllegalMonitorStateException`异常！（`synchronized(Object obj)`中的`obj`参数即为调用上述三个方法的对象）。

举例如下所示：

```java
public class WaitNotifyTest {
    static boolean flag = true;

    static Object lock = new Object();

    public static void main(String[] args) throws InterruptedException {
        Thread wait = new Thread(new WaitThread(), "WaitThread");
        Thread notify = new Thread(new NotifyThread(), "NotifyThread");
        wait.start();
        Thread.sleep(50);
        notify.start();
    }

    static class WaitThread implements Runnable {
        public void run() {
            synchronized (lock) {
                // 获取得到同步锁后，如果不满足条件则释放同步锁并等待
                while (flag) {
                    try {
                        System.out.println(Thread.currentThread().getName() + ": flag is true, wait...");
                        lock.wait();
                    } catch (InterruptedException e) {
                        // 响应外部中断
                        System.out.println(Thread.currentThread().getName() + ": interrupted!");
                        break;
                    }
                }
                System.out.println(Thread.currentThread().getName() + ": running...");
            }
        }
    }

    static class NotifyThread implements Runnable {
        public void run() {
            synchronized (lock) {
                System.out.println(Thread.currentThread().getName() + ": hold the lock, notify other threads!");
                // 唤醒其它wait线程，修改wait的执行条件
                lock.notifyAll();
                flag = false;
                
                // 手动延迟一段时间后再释放锁
                try {
                    Thread.sleep(50);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            // 再次获取同步锁(需要和已经被唤醒的线程竞争该锁)
            synchronized (lock) {
                System.out.println(Thread.currentThread().getName() + ": hold the lock again, sleep for 30 ms!");

                try {
                    Thread.sleep(30);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

// ----- 输出打印 ------------
/*
WaitThread: flag is true, wait...
NotifyThread: hold the lock, notify other threads!
NotifyThread: hold the lock again, sleep for 30 ms!
WaitThread: running...
*/
// 其中第三条和第四条打印可能互换顺序, 因为两个线程需要竞争同步锁
```

> wait() 应配合while循环使用，不应使用if（防止过早/意外通知），务必在wait()调用前后都检查条件，如果不满足，必须调用notify()唤醒另外的线程来处理，自己继续wait()直至条件满足再往下执行。

#### 1.6.1 线程中的`sleep()`和`wait()`的异同

- 两者均可使得当前线程进入阻塞/等待状态。
- `wait()`定义在`java.lang.Object`类中，它的调用者是线程监视器对象，该方法必须在同步代码块中调用。**该操作会释放当前的同步锁**。
- `sleep()`定义在`Thread`类中，是一个静态方法，可以在任何地方调用。**该操作不释放同步锁**。

#### 1.6.2 线程中的`notify()`和`notifyAll()`的异同

**`notify()`**

- 将一个线程唤醒（随机或者更根据线程优先级），该线程从等待池进入锁池（WAITING-->RUNNABLE-->BLOCKED?）

- 可能引发死锁/线程频繁挂起？

  > **两个生产者两个消费者**的场景:
  >
  > 如果我们代码中使用了notify()而非notifyAll()，
  >
  > - 假设消费者线程1拿到了锁，判断buffer为空，那么wait()，释放锁；
  > - 然后消费者2拿到了锁，同样buffer为空，wait()，也就是说此时Wait Set中有两个线程；
  > - 然后生产者1拿到锁，生产，buffer满，notify()了，那么可能消费者1被唤醒了，但是此时还有另一个线程生产者2在Entry Set中盼望着锁，**并且最终抢占到了锁**，但因为此时buffer是满的，因此它要wait()；
  > - 然后消费者1拿到了锁，消费，notify()；这时就有问题了，此时生产者2和消费者2都在Wait Set中，buffer为空，如果唤醒生产者2，没毛病；但如果唤醒了消费者2，因为buffer为空，它会再次wait()，这就尴尬了，**万一生产者1此时已经退出不再生产了**，没有其他线程在竞争锁了，只有生产者2和消费者2在Wait Set中互相等待，那传说中的死锁就发生了。

**`notifyAll()`**

- 将所有线程唤醒，等待池中的所有线程进入锁池（WAITING-->BLOCKED）
- 可能引发惊群效应，耗费系统资源。

**参考**

- [java中的notify和notifyAll有什么区别？ - youjia的回答 - 知乎](https://www.zhihu.com/question/37601861/answer/343143138)
- [java中的notify和notifyAll有什么区别？ - 知乎用户的回答 - 知乎](https://www.zhihu.com/question/37601861/answer/145545371)
- [线程间协作：wait、notify、notifyAll - Java 并发编程 - 极客学院Wiki (jikexueyuan.com)](https://wiki.jikexueyuan.com/project/java-concurrency/collaboration-between-threads.html)
- [你真的懂wait、notify和notifyAll吗 - 简书 (jianshu.com)](https://www.jianshu.com/p/25e243850bd2?appinstall=0)

#### 1.6.3 生产者消费者问题

场景：生产者负责生产产品，一旦产品库存满了则停止生产，直到库房空的位置则开始继续生产。消费者负责消费产品，一旦产品库存为0则需要等待，同时通知生产者开始生产产品。

具体实现代码如下所示：

```java
// 店员
class Clerk {
    // 产品库存数量
    private int productCount = 0;
    // 产品编号
    private int productNum = 0;
    // 原料库存数量
    private int materialCount = 20;

    public synchronized void product() throws InterruptedException {
        if (productCount < 10) {
            if (materialCount <= 0) {
                System.out.println(Thread.currentThread().getName() + ":原料已耗尽！停产！");
                Thread.currentThread().stop();  // ???过时
            }

            productNum++;
            productCount++;
            materialCount--;
            System.out.println(Thread.currentThread().getName() + ":生产第" + productNum + "件产品, " +
                    " 当前产品库存:" + productCount + " 当前原料剩余:" + materialCount);

            // 通知消费者可以消费了
            this.notifyAll();
        } else {
            System.out.println(Thread.currentThread().getName() + ":产品库存已满, 无法继续生产, 等待消费...");
            this.wait();
        }
    }

    public synchronized void consume() throws InterruptedException {
        if (productCount > 0) {
            productCount--;
            System.out.println(Thread.currentThread().getName() + ":消费1件产品," +
                    " 当前产品库存:" + productCount);

            // 通知生产者可以生产了
            this.notifyAll();
        } else {
            System.out.println(Thread.currentThread().getName() + ":产品库存为0, 正在等待生产...");
            this.wait();
        }
    }
}

// 生产者
class Producer implements Runnable {
    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    public void run() {
        while (true) {
            try {
                clerk.product();
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// 消费者
class Consumer implements Runnable {
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    public void run() {
        while (true) {
            try {
                clerk.consume();
                Thread.sleep(70);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

// 测试代码
public class ProducerConsumerTest {
    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Producer p1 = new Producer(clerk);
        Thread tp1 = new Thread(p1);
        tp1.setName("生产者1");

        Consumer c1 = new Consumer(clerk);
        Thread tc1 = new Thread(c1);
        tc1.setName("消费者1");
        Consumer c2 = new Consumer(clerk);
        Thread tc2 = new Thread(c2);
        tc2.setName("消费者2");

        tp1.start();
        tc1.start();
        tc2.start();
    }
}

// ---- 打印输出 ----
/*
生产者1:生产第1件产品,  当前产品库存:1 当前原料剩余:19
消费者1:消费1件产品, 当前产品库存:0
消费者2产品库存为0, 正在等待生产...
生产者1:生产第2件产品,  当前产品库存:1 当前原料剩余:18
生产者1:生产第3件产品,  当前产品库存:2 当前原料剩余:17
消费者1:消费1件产品, 当前产品库存:1
生产者1:生产第4件产品,  当前产品库存:2 当前原料剩余:16
消费者2:消费1件产品, 当前产品库存:1
生产者1:生产第5件产品,  当前产品库存:2 当前原料剩余:15
消费者1:消费1件产品, 当前产品库存:1
生产者1:生产第6件产品,  当前产品库存:2 当前原料剩余:14
消费者2:消费1件产品, 当前产品库存:1
生产者1:生产第7件产品,  当前产品库存:2 当前原料剩余:13
生产者1:生产第8件产品,  当前产品库存:3 当前原料剩余:12
消费者1:消费1件产品, 当前产品库存:2
生产者1:生产第9件产品,  当前产品库存:3 当前原料剩余:11
消费者2:消费1件产品, 当前产品库存:2
生产者1:生产第10件产品,  当前产品库存:3 当前原料剩余:10
消费者1:消费1件产品, 当前产品库存:2
生产者1:生产第11件产品,  当前产品库存:3 当前原料剩余:9
消费者2:消费1件产品, 当前产品库存:2
生产者1:生产第12件产品,  当前产品库存:3 当前原料剩余:8
消费者1:消费1件产品, 当前产品库存:2
生产者1:生产第13件产品,  当前产品库存:3 当前原料剩余:7
消费者2:消费1件产品, 当前产品库存:2
生产者1:生产第14件产品,  当前产品库存:3 当前原料剩余:6
消费者1:消费1件产品, 当前产品库存:2
生产者1:生产第15件产品,  当前产品库存:3 当前原料剩余:5
消费者2:消费1件产品, 当前产品库存:2
生产者1:生产第16件产品,  当前产品库存:3 当前原料剩余:4
生产者1:生产第17件产品,  当前产品库存:4 当前原料剩余:3
消费者1:消费1件产品, 当前产品库存:3
生产者1:生产第18件产品,  当前产品库存:4 当前原料剩余:2
消费者2:消费1件产品, 当前产品库存:3
生产者1:生产第19件产品,  当前产品库存:4 当前原料剩余:1
生产者1:生产第20件产品,  当前产品库存:5 当前原料剩余:0
消费者1:消费1件产品, 当前产品库存:4
消费者2:消费1件产品, 当前产品库存:3
生产者1:原料已耗尽！停产！
消费者1:消费1件产品, 当前产品库存:2
消费者2:消费1件产品, 当前产品库存:1
消费者2:消费1件产品, 当前产品库存:0
消费者1:产品库存为0, 正在等待生产...
消费者2:产品库存为0, 正在等待生产...
*/
```

**一定要注意**：调用`wait()`和`notify()`函数的对象必须为同一个监视器对象（如果是同步代码块则为通过传入参数指定的Obj，如果是同步方法则为执行该同步方法的当前对象）。

## 2. Java中的锁

### 共享带来的问题

Java 的体现：两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？

```java
static int counter = 0;
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            counter++;
        }
    }, "t1");

    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            counter--;
        }
    }, "t2");

    t1.start();
    t2.start();
    t1.join();
    t2.join();

    log.debug("{}",counter);
}
```

问题分析：以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理解，必须从字节码来进行分析 

例如对于` i++` 而言（i 为静态变量），实际会产生如下的 JVM 字节码指令：

```java
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
iadd // 自增
putstatic i // 将修改后的值存入静态变量i
```

而对应` i-- `也是类似：

```java
getstatic i // 获取静态变量i的值
iconst_1 // 准备常量1
isub // 自减
putstatic i // 将修改后的值存入静态变量i
```

而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换：

![img](assets/1649078017021-095fbc4b-0bfe-43e2-a5bb-b2e501d1d72c.png)

如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题：

![img](assets/1649078092550-95e8072d-74f0-440e-9d68-20ddcf5b7dbe.png)

但多线程下这 8 行代码可能交错运行： 

出现负数的情况：

![img](assets/1649078114541-bd43ccb1-52e4-4376-8b02-16cf05773e3b.png)

出现正数的情况：

![img](assets/1649078132446-5a44aa0c-a244-4d0c-9435-0ee54bc35332.png)

临界区 Critical Section

- 一个程序运行多个线程本身是没有问题的 

- 问题出在多个线程访问**共享资源** 

- - 多个线程读**共享资源**其实也没有问题 
  - 在多个线程对**共享资源**读写操作时发生指令交错（非原子性的操作交错进行），就会出现问题 

- 一段代码块内如果存在对**共享资源**的多线程读写操作，称这段代码块为**临界区** 

例如，下面代码中的临界区

```java
static int counter = 0;
static void increment()
// 临界区
{
    counter++; 
}
static void decrement()
// 临界区
{
    counter--; 
}
```

竞态条件 Race Condition：多个线程在临界区内执行，由于代码的**执行序列不同**而导致结果无法预测，称之为发生了**竞态条件**——也就是并发情境下

为了避免临界区的竞态条件发生，有多种手段可以达到目的。 

- 阻塞式的解决方案：synchronized，Lock 
- 非阻塞式的解决方案：原子变量 

### synchronized

`synchronized`是一种同步锁/监视器/对象锁，同时时刻只有一个线程会获取到这个锁，其它线程进入同步队列中等待（阻塞状态）。被`synchronized`修饰的方法或者代码块在同一时间只有一个线程在执行，保证了线程对变量访问的可见性和排他性！

虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： 

- 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 
- 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点



```java
// 使用synchronized使其安全
static int counter = 0;
static final Object room = new Object();
public static void main(String[] args) throws InterruptedException {
    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter++;
            }
        }
    }, "t1");

    Thread t2 = new Thread(() -> {
        for (int i = 0; i < 5000; i++) {
            synchronized (room) {
                counter--;
            }
        }
    }, "t2");

    t1.start();
    t2.start();
    t1.join();
    t2.join();
    log.debug("{}",counter);
}
// 使用面向对象改进：把共享变量放入到一个类中，类对外提供线程安全的操作方法
class Room {
    int value = 0;
    public void increment() {
        synchronized (this) {
            value++;
        }
    }
    public void decrement() {
        synchronized (this) {
            value--;
        }
    }
    public int get() {
        synchronized (this) {
            return value;
        }
    }
}
@Slf4j
public class Test1 {
    public static void main(String[] args) throws InterruptedException {
        Room room = new Room();
        Thread t1 = new Thread(() -> {
            for (int j = 0; j < 5000; j++) {
                room.increment();
            }
        }, "t1");
        Thread t2 = new Thread(() -> {
            for (int j = 0; j < 5000; j++) {
                room.decrement();
            }
        }, "t2");
        t1.start();
        t2.start();
        t1.join();
        t2.join();
        log.debug("count: {}" , room.get());
    }
}
```



#### 使用形式

1）同步代码块，锁是`synchronized(Object obj)`括号中传入的对象`obj`

```java
synchronized(obj) {

}
```

2）静态同步方法，锁是当前类的Class对象`XXX.class`

```java
public synchronized static void test() {   

}
// 等价于
public static void test() {
    synchronized(Test.class) {

    }
}
```

2）普通同步方法，锁是当前方法所属的实例对象`this`

```java
class Test{
    public synchronized void test() {

    }
}
// 等价于
class Test{
    public void test() {
        synchronized(this) {

        }
    }
}
```

3）静态同步方法，锁是当前类的Class对象`XXX.class`

```java
class Test{
    public synchronized static void test() {

    }
}
// 等价于
class Test{
    public static void test() {
        synchronized(Test.class) {

        }
    }
}
```

#### “线程八锁”案例分析

其实就是考察 synchronized 锁住的是哪个对象 

1.两个普通同步方法，两个线程，标准打印，打印？//one two
2.新增Thread.sleep() 给getOne,打印?one two
3.新增普通方法getThree(),打印？//three one two
4.两个普通同步方法，两个Number对象，打印？//two one
5.修改getOne()为静态同步方法，打印？// two one
6.修改两个方法均为静态同步方法，一个Number对象？//One Two
7.一个静态同步方法,一个非静态同步方法，两个Number对象，打印？//two one
8.两个静态同步方法，两个number对象？打印？//one two

#### 变量的线程安全分析

**成员变量和静态变量是否线程安全？** 

- 如果它们没有共享，则线程安全 

- 如果它们被共享了（被多个线程共享），根据它们的状态是否能够改变，又分两种情况 

- - 如果只有读操作，则线程安全 
  - 如果有读写操作，则这段代码是临界区，需要考虑线程安全 

**局部变量是否线程安全？** 

- 局部变量是线程安全的 

- 但局部变量引用的对象则未必 

- - 如果该对象没有逃离方法的作用访问，它是线程安全的 
  - 如果该对象逃离方法的作用范围，需要考虑线程安全



#### synchronized原理-Monitor

Java 对象头：以 32 位虚拟机为例

普通对象，一个对象的构成为（对象头+实例数据+填充），对象头的构成为以下三个部分：Mark Word （主要用来存储对象自身的运行时数据）、Klass Word （指向Class对象）、数组长度（数组对象独有）

![img](assets/1649081202993-bd236bb4-a971-4f15-87a1-f2a058958f3c.png)

![img](assets/1649081220496-eb45aee3-9713-43ce-a77e-9967987344cd.png)

Mark Word 结构由32位或者64位组成，32位虚拟机Mark Word 结构的各部分含义如下：

![img](assets/1649081240952-98e4241a-9de3-4379-8e72-6267a688f801.png)

64 位虚拟机 Mark Word

<img src="assets/image-20220929191108402.png" alt="image-20220929191108402" style="zoom:70%;" />

原理和加锁过程：

Monitor 被翻译为**监视器**或**管程** 

每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的Mark Word 中就被设置指向 Monitor 对象的指针

```java
ObjectMonitor {
    _count = 0;	// 锁计数器
    _owner = NULL;	// 持有锁的线程对象
    _WaitSet = NULL;	// 阻塞等待锁的线程对象集合
    _WaitSetLock = 0;
    _EntryList = NULL:
}
```

其次，使用`synchronized`修饰代码块时，会在代码块的开始和结尾分别插入`monitorenter`和`monitorexit`指令：

- 当执行`monitorenter`指令时，会检查monitor对象的count字段，如果为0（或者不为0但是_owner为自己，重入！）则表示可加锁，加锁后count+1，否则加锁失败开始阻塞。
- 当执行`monitorexit`指令时，将monitor对象的count字段减1。

Monitor 结构如下

![img](assets/1649148040964-e218970b-8514-4dbe-9f63-b49f98df97cd.png)

- 刚开始 Monitor 中 Owner 为 null 
- 当 Thread-2 执行 synchronized(obj) 会将该对象头的Mark Word 设置指向 Monitor 对象，然后将该Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一个 Owner 
- 在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入EntryList BLOCKED 
- Thread-2 执行完同步代码块的内容，重置锁对象的Mark Word字段，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的 
- 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程，后面讲wait-notify 时会分析

**注意：** 

- synchronized 必须是进入同一个对象的 monitor 才有上述的效果 
- 不加 synchronized 的对象不会关联监视器，不遵从以上规则



#### synchronized 进阶 (锁升级)

##### 1. (不涉及Monitor的)轻量级锁

轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以使用轻量级锁来优化。 

轻量级锁对使用者是透明的，即语法仍然是 `synchronized` 

假设有两个方法同步块，利用同一个对象加锁

```java
static final Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
        // 同步块 A
        method2();
    }
}

public static void method2() {
    synchronized( obj ) {
        // 同步块 B
    }
}
```

轻量级锁的原理：——使用锁记录Lock Record代替管程monitor

- 创建 锁记录（Lock Record）对象，每个线程的栈帧都会包含一个锁记录的结构，内部可以存储锁对象的Mark Word 

![img](assets/1649160876425-a5100f7f-2c33-44ba-a83a-7e57731d597f.png)

- 让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存入锁记录

![img](assets/1649160912986-dd53d480-9afc-4744-bb81-a6fb474b8e1b.png)

- 如果 cas 替换成功，对象头中存储了 `锁记录地址和状态 00 `，表示由该线程给对象加锁，这时图示如下

  ![img](assets/1649162377975-f3d8ce1b-4cb3-4a25-bfb1-f545ee685077.png)

- 如果 cas 失败，有两种情况 

- - 如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程
  - 如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数

![img](assets/1649160962695-8ad730a7-e98d-4394-b8e8-9993a8bcd274.png)

- 当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重入计数减一

![img](assets/1649160983980-427a6592-1cb0-4fa2-ab8f-301a8d3cfdde.png)

- 当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象头 

- - 成功，则解锁成功 
  - 失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程

##### 2. (轻量级)锁膨胀 / 锁升级(为重量级锁)

如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。——升级为重量级锁，是为了记录后面有哪些竞争线程，方便在琐使用后唤醒它们

```java
static Object obj = new Object();
public static void method1() {
    synchronized( obj ) {
        // 同步块
    }
}
```

- 当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁

![img](assets/1649161048741-305206b8-422d-46fd-8470-695dc1123123.png)

- 这时 Thread-1 加轻量级锁失败，进入锁膨胀流程 

- - 即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 
  - 然后自己进入 Monitor 的 EntryList BLOCKED

![img](assets/1649161069072-eca53350-3cba-4e2a-8ff7-3b95f1c2d1b8.png)

- 当 Thread-0 退出同步块解锁时，使用 cas 将 Mark Word 的值恢复给对象头，失败。这时会进入重量级解锁流程，即按照 Monitor 地址找到 Monitor 对象，设置 Owner 为 null，唤醒 EntryList 中 BLOCKED 线程

##### 3. (竞争重量级锁时的)自旋优化

重量级锁竞争的时候，还可以使用自旋(实际上是循环尝试获取重量级锁)来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞。 (进入阻塞再恢复,会发生上下文切换,比较耗费性能)——应用在多核cpu中（有多个线程并行情况下）

自旋重试成功的情况

<img src="assets/image-20220930141608871.png" alt="image-20220930141608871" style="zoom:50%;" />

自旋重试失败的情况

<img src="assets/image-20220930141628116.png" alt="image-20220930141628116" style="zoom:50%;" />

- 自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 
- 在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会高，就多自旋几次；反之，就少自旋甚至不自旋，总之，比较智能。 
- Java 7 之后不能控制是否开启自旋功能（默认开启）

##### 4. (比轻量级锁更轻的)偏向锁

轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 ——解决线程重入时需要多次CAS

Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有 

这里的线程id是操作系统赋予的id 和 Thread的id是不同的

例如： 

```java
static final Object obj = new Object();

public static void m1() {
    synchronized( obj ) {
        // 同步块 A
        m2();
    }
}

public static void m2() {
    synchronized( obj ) {
        // 同步块 B
        m3();
    }
}

public static void m3() {
    synchronized( obj ) {
        // 同步块 C
    }
}
```

<img src="assets/image-20220930142326254.png" alt="image-20220930142326254" style="zoom:50%;" />

<img src="assets/image-20220930142347903.png" alt="image-20220930142347903" style="zoom:50%;" />

###### **偏向状态**

回忆一下对象头格式

<img src="assets/image-20220930142455652.png" alt="image-20220930142455652" style="zoom:50%;" />

一个对象创建时： 

- 如果开启了偏向锁（默认开启），那么对象创建后，markword 值为 0x05 即最后 3 位为 101，这时它的 thread、epoch、age 都为 0 
- 偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 `-XX:BiasedLockingStartupDelay=0` 来`禁用延迟` 
- 如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、age 都为 0，第一次用到 hashcode 时才会赋值

1） 测试延迟特性

偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 `-XX:BiasedLockingStartupDelay=0` 来`禁用延迟` 

2） 测试偏向锁

```
class Dog {}
```

利用 jol 第三方工具来查看对象头信息（注意这里up主扩展了 jol 让它输出更为简洁）

这里视频里引入的依赖貌似是他自己做的jar包,代码我就没写了,

代码很简单,重在理解对象头MarkWord

```java
public static void main(String[] args) throws IOException {
    Dog d = new Dog();
    ClassLayout classLayout = ClassLayout.parseInstance(d);

    new Thread(() -> {
        log.debug("synchronized 前");
        System.out.println(classLayout.toPrintableSimple(true));
        synchronized (d) {
            log.debug("synchronized 中");
            System.out.println(classLayout.toPrintableSimple(true));
        }
        log.debug("synchronized 后");
        System.out.println(classLayout.toPrintableSimple(true));
    }, "t1").start();
}
```

输出

```java
11:08:58.117 c.TestBiased [t1] - synchronized 前
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 
11:08:58.121 c.TestBiased [t1] - synchronized 中
00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101 
11:08:58.121 c.TestBiased [t1] - synchronized 后
00000000 00000000 00000000 00000000 00011111 11101011 11010000 00000101
```

**注意** ：处于偏向锁的对象解锁后，线程 id 仍存储于对象头中，也就是偏(心)向某个线程了

3）测试禁用

在上面测试代码运行时在添加 VM 参数 `-XX:-UseBiasedLocking`` 禁用偏向锁` 

输出 

```java
11:13:10.018 c.TestBiased [t1] - synchronized 前
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
11:13:10.021 c.TestBiased [t1] - synchronized 中
00000000 00000000 00000000 00000000 00100000 00010100 11110011 10001000 
11:13:10.021 c.TestBiased [t1] - synchronized 后
00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001
```

4) 测试 hashCode

在`Dog d = new Dog();`后加上一句 `d.hashCode();`

- 正常状态对象一开始是没有 hashCode 的，第一次调用才生成
- 调用了 hashCode() 后会撤销该对象的偏向锁



###### 撤销(偏向) - 调用对象 hashCode

调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销 

- 轻量级锁会在锁记录中记录 hashCode 
- 重量级锁会在 Monitor 中记录 hashCode 

记得去掉 `-XX:-UseBiasedLocking`

在调用 hashCode 后使用偏向锁，输出

```java
11:22:10.386 c.TestBiased [main] - 调用 hashCode:1778535015 
11:22:10.391 c.TestBiased [t1] - synchronized 前
00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001 
11:22:10.393 c.TestBiased [t1] - synchronized 中
00000000 00000000 00000000 00000000 00100000 11000011 11110011 01101000 
11:22:10.393 c.TestBiased [t1] - synchronized 后
00000000 00000000 00000000 01101010 00000010 01001010 01100111 00000001
```

###### 撤销(偏向) - 其它线程(错开)使用对象

当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁。（但不是同时间段使用，如果同时间段使用则会再次升级为重量级锁）

```java
private static void test2() throws InterruptedException {
    Dog d = new Dog();

    Thread t1 = new Thread(() -> {

        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));
        synchronized (d) {
            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));
        }
        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));

        synchronized (TestBiased.class) {
            TestBiased.class.notify();
        }
        // 如果不用 wait/notify 使用 join 必须打开下面的注释
        // 因为：t1 线程不能结束，否则底层线程可能被 jvm 重用作为 t2 线程，底层线程 id 是一样的
        /*try {
            System.in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }*/
    }, "t1");
    t1.start();

    Thread t2 = new Thread(() -> {
        synchronized (TestBiased.class) {
            try {
                TestBiased.class.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));
        synchronized (d) {
            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));
        }
        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));
    }, "t2");
    t2.start();
}
```

输出

![img](assets/1649170087431-26a16998-3421-40e5-918e-29e1f9a15d50.png)

###### 撤销(偏向) - 调用 wait/notify

重量级锁才支持 wait/notify

```java
public static void main(String[] args) throws InterruptedException {
    Dog d = new Dog();

    Thread t1 = new Thread(() -> {
        log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));
        synchronized (d) {
            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));
            try {
                d.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug(ClassLayout.parseInstance(d).toPrintableSimple(true));
        }
    }, "t1");
    t1.start();

    new Thread(() -> {
        try {
            Thread.sleep(6000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        synchronized (d) {
            log.debug("notify");
            d.notify();
        }
    }, "t2").start();
}
```

输出

```java
[t1] - 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000101 
[t1] - 00000000 00000000 00000000 00000000 00011111 10110011 11111000 00000101 
[t2] - notify 
[t1] - 00000000 00000000 00000000 00000000 00011100 11010100 00001101 11001010
```

###### 批量重偏向

如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象的 Thread ID 

当(某类型对象)撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给（所有这种类型的状态为偏向锁的）对象加锁时重新偏向至新的加锁线程

这里略有些不好用文字说明,看例子吧

注意t2-19处的变化: 发生了批量重偏向

```java
private static void test3() throws InterruptedException {

    Vector<Dog> list = new Vector<>();

    Thread t1 = new Thread(() -> {
        for (int i = 0; i < 30; i++) {
            Dog d = new Dog();
            list.add(d);
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
        }
        synchronized (list) {
            list.notify();
        }
    }, "t1");
    t1.start();

    Thread t2 = new Thread(() -> {
        synchronized (list) {
            try {
                list.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        log.debug("===============> ");
        for (int i = 0; i < 30; i++) {
            Dog d = list.get(i);
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
        }
    }, "t2");
    t2.start();
}
```

输出

```java
[t1] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t1] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - ===============> 
[t2] - 0 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 0 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 0 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 1 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 1 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 2 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 2 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 2 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 3 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 3 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 3 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 4 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 4 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 4 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 5 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 5 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 5 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 6 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 6 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 6 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 7 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101
[t2] - 7 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 7 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 8 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 8 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 8 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 9 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 9 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 9 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 10 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 10 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 10 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 11 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 11 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 11 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 12 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 12 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 12 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 13 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 13 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 13 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 14 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 14 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 14 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 15 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 15 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 15 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 16 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 16 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 16 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 17 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 17 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 17 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 18 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 18 00000000 00000000 00000000 00000000 00100000 01011000 11110111 00000000 
[t2] - 18 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001 
[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 19 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 20 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 21 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 22 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 23 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 24 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 25 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 26 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 27 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 28 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11100000 00000101 
[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101 
[t2] - 29 00000000 00000000 00000000 00000000 00011111 11110011 11110001 00000101
```

###### 批量撤销(偏向)

当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象都会变为不可偏向的，新建的该类型对象也是不可偏向的 

```java
static Thread t1,t2,t3;
private static void test4() throws InterruptedException {
    Vector<Dog> list = new Vector<>();

    int loopNumber = 39;
    t1 = new Thread(() -> {
        for (int i = 0; i < loopNumber; i++) {
            Dog d = new Dog();
            list.add(d);
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
        }
        LockSupport.unpark(t2);
    }, "t1");
    t1.start();

    t2 = new Thread(() -> {
        LockSupport.park();
        log.debug("===============> ");
        for (int i = 0; i < loopNumber; i++) {
            Dog d = list.get(i);
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
        }
        LockSupport.unpark(t3);
    }, "t2");
    t2.start();

    t3 = new Thread(() -> {
        LockSupport.park();
        log.debug("===============> ");
        for (int i = 0; i < loopNumber; i++) {
            Dog d = list.get(i);
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            synchronized (d) {
                log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
            }
            log.debug(i + "\t" + ClassLayout.parseInstance(d).toPrintableSimple(true));
        }
    }, "t3");
    t3.start();

    t3.join();
    log.debug(ClassLayout.parseInstance(new Dog()).toPrintableSimple(true));
}
```

**参考资料** 

https://github.com/farmerjohngit/myblog/issues/12

https://www.cnblogs.com/LemonFive/p/11246086.html

https://www.cnblogs.com/LemonFive/p/11248248.html

偏向锁论文:  https://www.oracle.com/technetwork/java/biasedlocking-oopsla2006-wp-149958.pdf

##### 5. 锁消除

锁消除      JIT即时编译器会对字节码做进一步优化

锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断到一段代码中，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行

示例1

```java
public String concatString(String s1, String s2, String s3) {
    return s1 + s2 + s3;
}
//我们也知道，由于String是一个不可变的类，对字符串的连接操作总是通过生成新的String对象来进行的，因此Javac编译器会对String连接做自动优化。在JDK 5之前，字符串加法会转化为StringBuffer对象的连续append()操作，在JDK 5及以后的版本中，会转化为StringBuilder对象的连续append()操作。即以上代码可能会变成以下所示的样子
public String concatString(String s1, String s2, String s3) {
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    sb.append(s3);
    return sb.toString();
}
// 每个StringBuffer.append()方法中都有一个同步块，锁就是sb对象。虚拟机观察变量sb，经过逃逸分析后会发现它的动态作用域被限制在concatString()方法内部。也就是sb的所有引用都永远不会逃逸到concatString()方法之外，其他线程无法访问到它，所以这里虽然有锁，但是可以被安全地消除掉。在解释执行时这里仍然会加锁，但在经过服务端编译器的即时编译之后，这段代码就会忽略所有的同步措施而直接执行 
```

示例2

```java
@Fork(1)
@BenchmarkMode(Mode.AverageTime)
@Warmup(iterations=3)
@Measurement(iterations=5)
@OutputTimeUnit(TimeUnit.NANOSECONDS)
public class MyBenchmark {
    static int x = 0;
    @Benchmark
    public void a() throws Exception {
        x++;
    }
    @Benchmark
    public void b() throws Exception {
        //这里的o是局部变量,不会被共享,JIT做热点代码优化时会做锁消除
        Object o = new Object();
        synchronized (o) {
            x++;
        }
    }
}
java -jar benchmarks.jar
```

发现两部分的差别并不大,甚至b加了锁比a没加锁还快

![img](assets/1649162063044-a8f1ccdf-205d-409e-a9db-3bf4f85bc141.png)

```
java -XX:-EliminateLocks -jar benchmarks.jar
```

使用 `-XX:-EliminateLocks`禁用锁消除后就会发现 b性能比a差劲多了

![img](assets/1649162085920-e5772206-f137-4739-b309-37755015153a.png)

##### 6. 锁粗化

对相同对象多次加锁，导致线程发生多次重入，可以使用锁粗化方式来优化，这不同于之前讲的细分锁的粒度。

原则上，我们在编写代码的时候，总是推荐将同步块的作用范围限制得尽量小——只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁

大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗

上述示例1 中代码2所示连续的append()方法就属于这类情况。如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部，以代码2为例，就是扩展到第一个append()操作之前直至最后一个append()操作之后，这样只需要加锁一次就可以了

参考文档：[锁消除、锁粗化、锁膨胀_KKKLxxx的博客-CSDN博客_锁消除和锁粗化](https://blog.csdn.net/qq_45404693/article/details/120750282)





###  wait / notify

wait/notify 用于：获得锁的当前线程如果因为其他原因或者条件不足（非锁，如等待io）而阻塞时，可以将锁暂时给到其他线程使用。等到条件满足了之后再被唤醒。

一般作为线程之间协作（同步）的手段

![img](assets/1649162162024-714e4f70-ec4d-4f04-b582-f0d596c3da08.png)

- Owner 线程发现其他条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 
- BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 
- BLOCKED 线程会在 Owner 线程释放锁时唤醒 
- WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入EntryList 重新竞争

——EntryList中线程是没有锁（锁条件不满足，其他条件满足），WaitSet队列线程是其他条件不满足（比如等待io结果）

##### API 介绍

- `obj.wait()` 让进入 object 监视器的线程到 waitSet 等待 
- `obj.notify()` 在 object 上正在 waitSet 等待的线程中挑一个唤醒 
- `obj.notifyAll()` 让 object 上正在 waitSet 等待的线程全部唤醒

它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法

```java
final static Object obj = new Object();

public static void main(String[] args) {
    new Thread(() -> {
        synchronized (obj) {
            log.debug("执行....");
            try {
                obj.wait(); // 让线程在obj上一直等待下去
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("其它代码....");
        }
    }).start();

    new Thread(() -> {
        synchronized (obj) {
            log.debug("执行....");
            try {
                obj.wait(); // 让线程在obj上一直等待下去
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            log.debug("其它代码....");
        }
    }).start();

    // 主线程两秒后执行
    sleep(2);
    log.debug("唤醒 obj 上其它线程");
    synchronized (obj) {
        obj.notify(); // 唤醒obj上一个线程
        // obj.notifyAll(); // 唤醒obj上所有等待线程
    }
}
```

notify 的一种结果

```java
20:00:53.096 [Thread-0] c.TestWaitNotify - 执行.... 
20:00:53.099 [Thread-1] c.TestWaitNotify - 执行.... 
20:00:55.096 [main] c.TestWaitNotify - 唤醒 obj 上其它线程
20:00:55.096 [Thread-0] c.TestWaitNotify - 其它代码....
```

notifyAll 的结果

```java
19:58:15.457 [Thread-0] c.TestWaitNotify - 执行.... 
19:58:15.460 [Thread-1] c.TestWaitNotify - 执行.... 
19:58:17.456 [main] c.TestWaitNotify - 唤醒 obj 上其它线程
19:58:17.456 [Thread-1] c.TestWaitNotify - 其它代码.... 
19:58:17.456 [Thread-0] c.TestWaitNotify - 其它代码....
```

`wait()` 方法会释放对象的锁，进入 WaitSet 等待区，从而让其他线程就机会获取对象的锁。无限制等待，直到notify 为止 

`wait(long n)` 有时限的等待, 到 n 毫秒后结束等待，或是被 notify



#### `sleep(long n)` 和 `wait(long n)` 的区别

- 1) sleep 是 Thread 方法，而 wait 是 Object 的方法 
- 2) sleep 不需要强制和 synchronized 配合使用，但 wait 需要和 synchronized 一起用 
- 3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 
- 4) 它们状态 TIMED_WAITING

#### wait notify 的使用

##### 使用示例

###### **step/例 1 : sleep会阻碍其它线程执行**

```java
static final Object room = new Object();
static boolean hasCigarette = false;
static boolean hasTakeout = false;
```

思考下面的解决方案好不好，为什么？

```java
new Thread(() -> {
    synchronized (room) {
        log.debug("有烟没？[{}]", hasCigarette);
        if (!hasCigarette) {
            log.debug("没烟，先歇会！");
            sleep(2);
        }
        log.debug("有烟没？[{}]", hasCigarette);
        if (hasCigarette) {
            log.debug("可以开始干活了");
        }
    }
}, "小南").start();

for (int i = 0; i < 5; i++) {
    new Thread(() -> {
        synchronized (room) {
            log.debug("可以开始干活了");
        }
    }, "其它人").start();
}

sleep(1);
new Thread(() -> {
    // 这里能不能加 synchronized (room)？ 不能
    hasCigarette = true;
    log.debug("烟到了噢！");
}, "送烟的").start();
```

输出

```java
20:49:49.883 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:49:49.887 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:49:50.882 [送烟的] c.TestCorrectPosture - 烟到了噢！
20:49:51.887 [小南] c.TestCorrectPosture - 有烟没？[true] 
20:49:51.887 [小南] c.TestCorrectPosture - 可以开始干活了
20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了
20:49:51.887 [其它人] c.TestCorrectPosture - 可以开始干活了
20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了
20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了
20:49:51.888 [其它人] c.TestCorrectPosture - 可以开始干活了
```

- 其它干活的线程，都要一直阻塞，效率太低 
- 小南线程必须睡足 2s 后才能醒来，就算烟提前送到，也无法立刻醒来 
- 加了 synchronized (room) 后，就好比小南在里面反锁了门睡觉，烟根本没法送进门，main 没加 synchronized 就好像 main 线程是翻窗户进来的 
- sleep妨碍其它人干活     解决方法，使用 wait - notify 



###### **step/例** 2 : wait替代sleep

思考下面的实现行吗，为什么？

```java
new Thread(() -> {
    synchronized (room) {
        log.debug("有烟没？[{}]", hasCigarette);
        if (!hasCigarette) {
            log.debug("没烟，先歇会！");
            try {
                room.wait(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        log.debug("有烟没？[{}]", hasCigarette);
        if (hasCigarette) {
            log.debug("可以开始干活了");
        }
    }
}, "小南").start();

for (int i = 0; i < 5; i++) {
    new Thread(() -> {
        synchronized (room) {
            log.debug("可以开始干活了");
        }
    }, "其它人").start();
}

sleep(1);
new Thread(() -> {
    synchronized (room) {
        hasCigarette = true;
        log.debug("烟到了噢！");
        room.notify();
    }
}, "送烟的").start();
```

输出

```java
20:51:42.489 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:51:42.493 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:42.493 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:42.494 [其它人] c.TestCorrectPosture - 可以开始干活了
20:51:43.490 [送烟的] c.TestCorrectPosture - 烟到了噢！
20:51:43.490 [小南] c.TestCorrectPosture - 有烟没？[true] 
20:51:43.490 [小南] c.TestCorrectPosture - 可以开始干活了
```

- 解决了其它干活的线程阻塞的问题 
- 但如果有其它线程也在等待条件呢？  



###### **step/例 3 : 多个线程都wait时，会发生虚假唤醒**

```java
new Thread(() -> {
    synchronized (room) {
        log.debug("有烟没？[{}]", hasCigarette);
        if (!hasCigarette) {
            log.debug("没烟，先歇会！");
            try {
                room.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        log.debug("有烟没？[{}]", hasCigarette);
        if (hasCigarette) {
            log.debug("可以开始干活了");
        } else {
            log.debug("没干成活...");
        }
    }
}, "小南").start();

new Thread(() -> {
    synchronized (room) {
        Thread thread = Thread.currentThread();
        log.debug("外卖送到没？[{}]", hasTakeout);
        if (!hasTakeout) {
            log.debug("没外卖，先歇会！");
            try {
                room.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        log.debug("外卖送到没？[{}]", hasTakeout);
        if (hasTakeout) {
            log.debug("可以开始干活了");
        } else {
            log.debug("没干成活...");
        }
    }
}, "小女").start();

sleep(1);
new Thread(() -> {
    synchronized (room) {
        hasTakeout = true;
        log.debug("外卖到了噢！");
        room.notify();
    }
}, "送外卖的").start();
```

输出

```java
20:53:12.173 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:53:12.176 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:53:12.176 [小女] c.TestCorrectPosture - 外卖送到没？[false] 
20:53:12.176 [小女] c.TestCorrectPosture - 没外卖，先歇会！
20:53:13.174 [送外卖的] c.TestCorrectPosture - 外卖到了噢！
20:53:13.174 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:53:13.174 [小南] c.TestCorrectPosture - 没干成活...
```

- notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线程，称之为【虚假唤醒】 
- 发生虚假唤醒: 解决方法，改为 notifyAll

###### step/例 4 : if+wait 仅有1次判断机会

```java
new Thread(() -> {
    synchronized (room) {
        hasTakeout = true;
        log.debug("外卖到了噢！");
        room.notifyAll();
    }
}, "送外卖的").start();
```

输出

```java
20:55:23.978 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:55:23.982 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:55:23.982 [小女] c.TestCorrectPosture - 外卖送到没？[false] 
20:55:23.982 [小女] c.TestCorrectPosture - 没外卖，先歇会！
20:55:24.979 [送外卖的] c.TestCorrectPosture - 外卖到了噢！
20:55:24.979 [小女] c.TestCorrectPosture - 外卖送到没？[true] 
20:55:24.980 [小女] c.TestCorrectPosture - 可以开始干活了
20:55:24.980 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:55:24.980 [小南] c.TestCorrectPosture - 没干成活...
```

- 用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新判断的机会了 
- notifyAll唤醒了所有,但使用if+wait仅有一次机会,解决方法，一旦条件不成立，就没有重新判断的机会了.解决办法: 用 while + wait，当条件不成立，再次 wait



###### step 5 : while+wait

将 if 改为 while

```java
if (!hasCigarette) {
    log.debug("没烟，先歇会！");
    try {
        room.wait();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

改动后

```java
while (!hasCigarette) {
    log.debug("没烟，先歇会！");
    try {
        room.wait();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
```

输出

```java
20:58:34.322 [小南] c.TestCorrectPosture - 有烟没？[false] 
20:58:34.326 [小南] c.TestCorrectPosture - 没烟，先歇会！
20:58:34.326 [小女] c.TestCorrectPosture - 外卖送到没？[false] 
20:58:34.326 [小女] c.TestCorrectPosture - 没外卖，先歇会！
20:58:35.323 [送外卖的] c.TestCorrectPosture - 外卖到了噢！
20:58:35.324 [小女] c.TestCorrectPosture - 外卖送到没？[true] 
20:58:35.324 [小女] c.TestCorrectPosture - 可以开始干活了
20:58:35.324 [小南] c.TestCorrectPosture - 没烟，先歇会！
synchronized(lock) {
    while(条件不成立) {
        lock.wait();
    }
    // 干活
}

//另一个线程
synchronized(lock) {
    lock.notifyAll();
}
```





##### *** (同步)模式之保护性暂停**

即 Guarded Suspension，用在一个线程等待另一个线程的执行结果 

###### 要点 

- 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject 
- 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者） 
- JDK 中，join 的实现、Future 的实现，采用的就是此模式 
- 因为要等待另一方的结果，因此归类到同步模式 

![img](assets/1649426331671-d1c40ad0-7864-438f-8c61-8717722b0ade.png)

###### 实现

```java
class GuardedObject {

    private Object response;
    private final Object lock = new Object();

    public Object get() {
        synchronized (lock) {
            // 条件不满足则等待
            while (response == null) {
                try {
                    lock.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } 
            }
            return response; 
        }
    }

    public void complete(Object response) {
        synchronized (lock) {
            // 条件满足，通知等待线程
            this.response = response;
            lock.notifyAll();
        }
    }

}
```

应用：一个线程等待另一个线程的执行结果

```java
public static void main(String[] args) {
    GuardedObject guardedObject = new GuardedObject();

    new Thread(() -> {
        try {
            // 子线程执行下载
            List<String> response = download();
            log.debug("download complete...");
            guardedObject.complete(response);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }).start();

    log.debug("waiting...");

    // 主线程阻塞等待
    Object response = guardedObject.get();
    log.debug("get response: [{}] lines", ((List<String>) response).size());
}
```

执行结果

```java
08:42:18.568 [main] c.TestGuardedObject - waiting...
08:42:23.312 [Thread-0] c.TestGuardedObject - download complete...
08:42:23.312 [main] c.TestGuardedObject - get response: [3] lines
```

###### 带超时版 GuardedObject

如果要控制超时时间呢

```java
class GuardedObjectV2 {
    private Object response;
    private final Object lock = new Object();

    public Object get(long millis) {
        synchronized (lock) {
            // 1) 记录最初时间
            long begin = System.currentTimeMillis();
            // 2) 已经经历的时间
            long timePassed = 0;

            while (response == null) {
                // 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等
                long waitTime = millis - timePassed;
                log.debug("waitTime: {}", waitTime);

                if (waitTime <= 0) {
                    log.debug("break...");
                    break; 
                }

                try {
                    lock.wait(waitTime);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

                // 3) 如果提前被唤醒，这时已经经历的时间假设为 400
                timePassed = System.currentTimeMillis() - begin;

                log.debug("timePassed: {}, object is null {}", 
                          timePassed, response == null);
            }
            return response; 
        }
    }
    public void complete(Object response) {
        synchronized (lock) {
            // 条件满足，通知等待线程
            this.response = response;
            log.debug("notify...");
            lock.notifyAll();
        }
    }
}
```

测试，没有超时

```java
public static void main(String[] args) {
    GuardedObjectV2 v2 = new GuardedObjectV2();

    new Thread(() -> {
        sleep(1);
        v2.complete(null);
        sleep(1);
        v2.complete(Arrays.asList("a", "b", "c"));
    }).start();

    Object response = v2.get(2500);
    if (response != null) {
        log.debug("get response: [{}] lines", ((List<String>) response).size());
    } else {
        log.debug("can't get response");
    }

}
```

输出

```java
08:49:39.917 [main] c.GuardedObjectV2 - waitTime: 2500
08:49:40.917 [Thread-0] c.GuardedObjectV2 - notify...
08:49:40.917 [main] c.GuardedObjectV2 - timePassed: 1003, object is null true
08:49:40.917 [main] c.GuardedObjectV2 - waitTime: 1497
08:49:41.918 [Thread-0] c.GuardedObjectV2 - notify...
08:49:41.918 [main] c.GuardedObjectV2 - timePassed: 2004, object is null false
08:49:41.918 [main] c.TestGuardedObjectV2 - get response: [3] lines
```

测试，超时

```java
// 等待时间不足
List<String> lines = v2.get(1500);
```

输出

```java
08:47:54.963 [main] c.GuardedObjectV2 - waitTime: 1500
08:47:55.963 [Thread-0] c.GuardedObjectV2 - notify...
08:47:55.963 [main] c.GuardedObjectV2 - timePassed: 1002, object is null true
08:47:55.963 [main] c.GuardedObjectV2 - waitTime: 498
08:47:56.461 [main] c.GuardedObjectV2 - timePassed: 1500, object is null true
08:47:56.461 [main] c.GuardedObjectV2 - waitTime: 0
08:47:56.461 [main] c.GuardedObjectV2 - break...
08:47:56.461 [main] c.TestGuardedObjectV2 - can't get response
08:47:56.963 [Thread-0] c.GuardedObjectV2 - notify...
```

###### join的原理

join的底层实现：实际上是通过同步锁synchronized中的wait / notify实现的

```java
public final synchronized void join(long millis)
    throws InterruptedException {
        long base = System.currentTimeMillis();
        long now = 0;

        if (millis < 0) {
            throw new IllegalArgumentException("timeout value is negative");
        }

        if (millis == 0) {
            while (isAlive()) {
                wait(0);
            }
        } else {
            while (isAlive()) {
                long delay = millis - now;
                if (delay <= 0) {
                    break;
                }
                wait(delay);
                now = System.currentTimeMillis() - base;
            }
        }
    }
```

###### 多任务版 GuardedObject

图中 Futures 就好比居民楼一层的信箱（每个信箱有房间编号），左侧的 t0，t2，t4 就好比等待邮件的居民，右侧的 t1，t3，t5 就好比邮递员 

如果需要在多个类之间使用 GuardedObject 对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类， 

这样不仅能够解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的管理

![img](assets/1649426679980-29e01354-3c06-4f59-acd8-1b782d4e420e.png)

新增 id 用来标识 Guarded Object

```java
class GuardedObject {
    // 标识 Guarded Object
    private int id;
    public GuardedObject(int id) {
        this.id = id;
    }
    public int getId() {
        return id;
    }
    // 结果
    private Object response;
    // 获取结果
    // timeout 表示要等待多久 2000
    public Object get(long timeout) {
        synchronized (this) {
            // 开始时间 15:00:00
            long begin = System.currentTimeMillis();
            // 经历的时间
            long passedTime = 0;
            while (response == null) {
                // 这一轮循环应该等待的时间
                long waitTime = timeout - passedTime;
                // 经历的时间超过了最大等待时间时，退出循环
                if (timeout - passedTime <= 0) {
                    break;
                }
                try {
                    this.wait(waitTime); // 虚假唤醒 15:00:01
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                // 求得经历时间
                passedTime = System.currentTimeMillis() - begin; // 15:00:02 1s
            }
            return response;
        }
    }
    // 产生结果
    public void complete(Object response) {
        synchronized (this) {
            // 给结果成员变量赋值
            this.response = response;
            this.notifyAll();
        }
    }
}
```

中间解耦类

```java
class Mailboxes {
    private static Map<Integer, GuardedObject> boxes = new Hashtable<>();

    private static int id = 1;
    // 产生唯一 id
    private static synchronized int generateId() {
        return id++;
    }

    public static GuardedObject getGuardedObject(int id) {
        return boxes.remove(id);
    }

    public static GuardedObject createGuardedObject() {
        GuardedObject go = new GuardedObject(generateId());
        boxes.put(go.getId(), go);
        return go;
    }

    public static Set<Integer> getIds() {
        return boxes.keySet();
    }
}
```

业务相关类

```java
class People extends Thread{
    @Override
    public void run() {
        // 收信
        GuardedObject guardedObject = Mailboxes.createGuardedObject();
        log.debug("开始收信 id:{}", guardedObject.getId());
        Object mail = guardedObject.get(5000);
        log.debug("收到信 id:{}, 内容:{}", guardedObject.getId(), mail);
    }
}
class Postman extends Thread {
    private int id;
    private String mail;
    public Postman(int id, String mail) {
        this.id = id;
        this.mail = mail;
    }
    @Override
    public void run() {
        GuardedObject guardedObject = Mailboxes.getGuardedObject(id);
        log.debug("送信 id:{}, 内容:{}", id, mail);
        guardedObject.complete(mail);
    }
}
```

测试

```java
public static void main(String[] args) throws InterruptedException {
    for (int i = 0; i < 3; i++) {
        new People().start();
    }
    Sleeper.sleep(1);
    for (Integer id : Mailboxes.getIds()) {
        new Postman(id, "内容" + id).start();
    }
}
```

某次运行结果

```java
10:35:05.689 c.People [Thread-1] - 开始收信 id:3
10:35:05.689 c.People [Thread-2] - 开始收信 id:1
10:35:05.689 c.People [Thread-0] - 开始收信 id:2
10:35:06.688 c.Postman [Thread-4] - 送信 id:2, 内容:内容2
10:35:06.688 c.Postman [Thread-5] - 送信 id:1, 内容:内容1
10:35:06.688 c.People [Thread-0] - 收到信 id:2, 内容:内容2
10:35:06.688 c.People [Thread-2] - 收到信 id:1, 内容:内容1
10:35:06.688 c.Postman [Thread-3] - 送信 id:3, 内容:内容3
10:35:06.689 c.People [Thread-1] - 收到信 id:3, 内容:内容3
```

##### *** (异步)模式之生产者/消费者**

###### 要点 

- 与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应 
- 消费队列可以用来平衡生产和消费的线程资源 
- 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 
- 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 
- JDK 中各种阻塞队列，采用的就是这种模式

![img](assets/1649432391569-d4b5bbfb-cff5-4aa4-9b27-58c860bd1855.png)

###### 实现

```java
class Message {
    private int id;
    private Object message;
    public Message(int id, Object message) {
        this.id = id;
        this.message = message;
    }
    public int getId() {
        return id;
    }
    public Object getMessage() {
        return message;
    }
}

class MessageQueue {
    private LinkedList<Message> queue;
    private int capacity;

    public MessageQueue(int capacity) {
        this.capacity = capacity;
        queue = new LinkedList<>();
    }

    public Message take() {
        synchronized (queue) {
            while (queue.isEmpty()) {
                log.debug("没货了, wait");
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            Message message = queue.removeFirst();
            queue.notifyAll();
            return message;
        }
    }

    public void put(Message message) {
        synchronized (queue) {
            while (queue.size() == capacity) {
                log.debug("库存已达上限, wait");
                try {
                    queue.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            queue.addLast(message);
            queue.notifyAll();
        }
    }
}
```

###### *** 应用**

```java
MessageQueue messageQueue = new MessageQueue(2);

// 4 个生产者线程, 下载任务
for (int i = 0; i < 4; i++) {
    int id = i;
    new Thread(() -> {
        try {
            log.debug("download...");
            List<String> response = Downloader.download();
            log.debug("try put message({})", id);
            messageQueue.put(new Message(id, response));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }, "生产者" + i).start();
}

// 1 个消费者线程, 处理结果
new Thread(() -> {
    while (true) {
        Message message = messageQueue.take();
        List<String> response = (List<String>) message.getMessage();
        log.debug("take message({}): [{}] lines", message.getId(), response.size());
    }
}, "消费者").start();
```

某次运行结果

```java
10:48:38.070 [生产者3] c.TestProducerConsumer - download...
10:48:38.070 [生产者0] c.TestProducerConsumer - download...
10:48:38.070 [消费者] c.MessageQueue - 没货了, wait
10:48:38.070 [生产者1] c.TestProducerConsumer - download...
10:48:38.070 [生产者2] c.TestProducerConsumer - download...
10:48:41.236 [生产者1] c.TestProducerConsumer - try put message(1)
10:48:41.237 [生产者2] c.TestProducerConsumer - try put message(2)
10:48:41.236 [生产者0] c.TestProducerConsumer - try put message(0)
10:48:41.237 [生产者3] c.TestProducerConsumer - try put message(3)
10:48:41.239 [生产者2] c.MessageQueue - 库存已达上限, wait
10:48:41.240 [生产者1] c.MessageQueue - 库存已达上限, wait
10:48:41.240 [消费者] c.TestProducerConsumer - take message(0): [3] lines
10:48:41.240 [生产者2] c.MessageQueue - 库存已达上限, wait
10:48:41.240 [消费者] c.TestProducerConsumer - take message(3): [3] lines
10:48:41.240 [消费者] c.TestProducerConsumer - take message(1): [3] lines
10:48:41.240 [消费者] c.TestProducerConsumer - take message(2): [3] lines
10:48:41.240 [消费者] c.MessageQueue - 没货了, wait
```

结果解读

### Park & Unpark

#### 基本使用

它们是 LockSupport 类中的方法

```java
// 暂停当前线程
LockSupport.park(); 
// 恢复某个线程的运行
LockSupport.unpark(暂停线程对象)
```

先 park 再 unpark

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(1);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
},"t1");
t1.start();

sleep(2);
log.debug("unpark...");
LockSupport.unpark(t1);
```

输出

```java
18:42:52.585 c.TestParkUnpark [t1] - start... 
18:42:53.589 c.TestParkUnpark [t1] - park... 
18:42:54.583 c.TestParkUnpark [main] - unpark... 
18:42:54.583 c.TestParkUnpark [t1] - resume...
```

先 unpark 再 park

```java
Thread t1 = new Thread(() -> {
    log.debug("start...");
    sleep(2);
    log.debug("park...");
    LockSupport.park();
    log.debug("resume...");
}, "t1");
t1.start();

sleep(1);
log.debug("unpark...");
LockSupport.unpark(t1);
```

输出

```java
18:43:50.765 c.TestParkUnpark [t1] - start... 
18:43:51.764 c.TestParkUnpark [main] - unpark... 
18:43:52.769 c.TestParkUnpark [t1] - park... 
18:43:52.769 c.TestParkUnpark [t1] - resume...
```

#### 特点

与 Object 的 wait & notify 相比 

- wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必
- park & unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll是唤醒所有等待线程，就不那么【精确】 
- park & unpark 可以先 unpark，而 wait & notify 不能先 notify 

#### * 原理之 park & unpark

每个线程都有自己的一个(C代码实现的) Parker 对象，由三部分组成 `_counter` ， `_cond` 和`_mutex` 

打个比喻 

- 线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中的备用干粮（0 为耗尽，1 为充足） 

- 调用 park 就是要看需不需要停下来歇息 

- - 如果备用干粮耗尽，那么钻进帐篷歇息 
  - 如果备用干粮充足，那么不需停留，继续前进 

- 调用 unpark，就好比令干粮充足 

- - 如果这时线程还在帐篷，就唤醒让他继续前进 
  - 如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留,继续前进 

- - - 因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮,也就是多次unpark后只会让紧跟着的一次park失效

##### 先调用park 再调用unpark

![img](assets/1649487498123-7ce23aed-2f31-4bb7-9b9d-d085ad4a4671.png)

\1. 当前线程调用 Unsafe.park() 方法 

\2. 检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁 

\3. 线程进入 _cond 条件变量阻塞 

\4. 设置 _counter = 0

![img](assets/1649487517056-37413514-28c8-4a12-adcb-560e87aa97a7.png)

\1. 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1 

\2. 唤醒 _cond 条件变量中的 Thread_0 

\3. Thread_0 恢复运行 

\4. 设置 _counter 为 0

##### 先调用unpark 再调用park

![img](assets/1649487540516-ad98c447-fb50-472e-b19f-deac45ab3fc9.png)

\1. 调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1 

\2. 当前线程调用 Unsafe.park() 方法 

\3. 检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行 

\4. 设置 _counter 为 0 



### 4.11 多把锁——锁细化

多把不相干的锁。一间大屋子有两个功能：睡觉、学习，互不相干。 

现在小南要学习，小女要睡觉，但如果只用一间屋子（一个对象锁）的话，那么并发度很低 

解决方法是准备多个房间（多个对象锁） 

例如

```java
class BigRoom {
    public void sleep() {
        synchronized (this) {
            log.debug("sleeping 2 小时");
            Sleeper.sleep(2);
        }
    }
    public void study() {
        synchronized (this) {
            log.debug("study 1 小时");
            Sleeper.sleep(1);
        }
    }
}
```

执行

```java
BigRoom bigRoom = new BigRoom();

new Thread(() -> {
    bigRoom.study();
},"小南").start();

new Thread(() -> {
    bigRoom.sleep();
},"小女").start();
```

某次结果

```java
12:13:54.471 [小南] c.BigRoom - study 1 小时
12:13:55.476 [小女] c.BigRoom - sleeping 2 小时
```

改进

```java
class BigRoom {
    private final Object studyRoom = new Object();
    private final Object bedRoom = new Object();

    public void sleep() {
        synchronized (bedRoom) {
            log.debug("sleeping 2 小时");
            Sleeper.sleep(2);
        }
    }

    public void study() {
        synchronized (studyRoom) {
            log.debug("study 1 小时");
            Sleeper.sleep(1);
        }
    }

}
```

某次执行结果

```java
12:15:35.069 [小南] c.BigRoom - study 1 小时
12:15:35.069 [小女] c.BigRoom - sleeping 2 小时
```

将锁的粒度细分 

- 好处，是可以增强并发度 
- 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁



### 常见线程安全类

- String 
- Integer 
- StringBuffer 
- Random 
- Vector 
- Hashtable 
- java.util.concurrent 包下的类

这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为

```java
Hashtable table = new Hashtable();

new Thread(()->{
    table.put("key", "value1");
}).start();

new Thread(()->{
    table.put("key", "value2");
}).start();
```

- 它们的每个方法是原子的 
- 但**注意**它们多个方法的组合不是原子的，见后面分析

#### 线程安全类方法的组合

分析下面代码是否线程安全？ 

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
    table.put("key", value);
}
```

![img](assets/1649080250688-7a126dfd-2ac5-4b34-99d5-d77a7ccbfb3c-1664440599801.png)

#### 不可变类线程安全性

String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 

有同学或许有疑问，String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安全的呢？

```java
public class Immutable{
    private int value = 0;
    public Immutable(int value){
        this.value = value;
    }
    public int getValue(){
        return this.value;
    }
}
```

如果想增加一个增加的方法呢？

```java
public class Immutable{
    private int value = 0;

    public Immutable(int value){
        this.value = value;
    }

    public int getValue(){
        return this.value;
    }

    public Immutable add(int v){
        return new Immutable(this.value + v);
    }
}
```





### volatile实现原理

被`volatile`修饰的共享变量对所有线程都是可见的（当一个线程修改变量值时另一个线程可以读到最新的修改值），JAVA的线程内存模型保证了这一点！

#### 内存语义

使用该关键字修饰额变量在编译成CPU指令的时候会多出一行Lock前缀指令：

- 该指令可以将当前CPU缓存的数据立即写到主内存中
- 写回操作会使得其他CPU里缓存了该内存地址的数据无效（需要重新把该数据从内存中读到CPU缓存中）

> <font color="red">volatile可以算是一种轻量级锁，无需进行线程上下文切换。</font>对`volatile`变量的读写是原子操作（即使是64bit的double或者long），**但是`volatile++`不是原子操作即线程不安全！**

> 用`volatile`来修饰成员变量，就是告知程序任何对该变量的访问都需要从主内存中获取（而不是本地的Cahche/工作内存），而对他的修改也必须同步刷新共享内存！
>
> `volatile`保证所有线程对变量访问的可见性！

#### 使用场景

- 写入变量值不依赖于变量的当前值（如boolean类型的变量？）。因为如果依赖当前值时：读-计算-写 三个步骤不具备原子性，volatile本身不保证原子性。
- 读写变量时没有加锁。因为加锁本身已经保证内存可见性了，无需重复处理。

### Lock实现原理

Lock锁是JDK1.5之后定义的锁的接口，里面定了获取/释放锁的方法，可由用户利用**AQS组件+CAS机制**实现自定义的锁。

#### 2.3.1 CAS机制

**CAS** (Compare And Swap) 是一种无锁实现`读-改-写`原子操作的机制。一个线程需要对内存中的值进行修改（如果+1操作），在把修改后的值写入该内存前会首先比较之前记录的该内存中的值和当前读取的该内存中的值是否相同，相同则提交写入操作，否则再次尝试上述修改过程【自旋】！

```text
########## CAS操作举例 #################
-------------------
|     |  10 |     |
-------------------
        V
已知内存地址V中当前存储的值为11.
线程A想对该值进行+1操作: a = V + 1; V = a;
线程B想对该值进行+2操作: b = V + 2; V = b;

- 当A在执行V = a = 11前线程被打断，CPU调度线程B进行执行，此时V内存储的值被更新为12;
- CPU再次调度线程A执行, 此时线程A对读取当前V中的值为12，和存储的旧值10不同, 于是写入操作失败
- 线程A再次尝试`a = V + 1; V = a`的操作，直到在提交更新(V = a)时V的旧值当前V值相同则提交！【自旋】

########## CAS实现原理 ###################
CAS操作基于CPU提供的原子操作指令实现。对于Intel X86处理器，可通过在汇编指令前增加LOCK前缀来锁定系统总线，使系统总线在汇编指令执行时无法访问相应的内存地址。而各个编译器根据这个特点实现了各自的原子操作函数。
  
JAVA中`sun.misc.Unsafe`提供了`compareAndSwap`系列函数。而`java.util.concurrent.atomic`中的原子类就使用了CAS机制。

CAS执行结果要么成功要么失败，对于失败的情形下一般不断重试或者放弃。
```

CAS的C代码实现：

```c
/**
 * @Brief CAS操作(必须是原子操作)
 * @Param addr 要提交更新的内存地址
 * @Param old 该内存值记录的旧值
 * @Param new 要更新到该内存中的新值 
 */
int cas(long *addr, long old, long new)
{
    /* Executes atomically. */
    if(*addr != old)
        return 0;
    *addr = new;
    return 1;
}
```

**ABA问题**

ABA问题是无锁结构实现中常见的一种问题，可基本表述为：

1. 进程P1读取了一个数值A
2. P1被挂起(时间片耗尽、中断等)，进程P2开始执行
3. P2修改数值A为数值B，然后又修改回A
4. P1被唤醒，比较后发现数值A没有变化，程序继续执行。

对于P1来说，数值A未发生过改变，但实际上A已经被变化过了，继续使用可能会出现问题。在一般情况下，这似乎没有什么问题，但是<font color="red">在没有垃圾回收或者具有内存重用机制的环境中会出现严重的问题</font>！试想如下情况：

```
   top
    |
    V   
  0x0014
| Node A | --> |  Node X | --> ……
```

有一个栈(先入后出)中有top和节点A，节点A目前位于栈顶top指针指向A。现在有一个进程P1想要pop一个节点，因此按照如下无锁操作进行

```
pop()
{
  do{
    ptr = top;            // ptr = top = NodeA
    next_prt = top->next; // next_ptr = NodeX
  } while(CAS(top, ptr, next_ptr) != true);
  return ptr;   
}
```

而进程P2在执行CAS操作之前打断了P1，并对栈进行了一系列的pop和push操作，使栈变为如下结构：

```
   top
    |
    V  
  0x0014
| Node C | --> | Node B | --> |  Node X | --> ……
```

进程P2首先pop出NodeA，之后又Push了两个NodeB和C，由于内存管理机制中广泛使用的内存重用机制，导致NodeC的地址与之前的NodeA一致。

这时P1又开始继续运行，在执行CAS操作时，由于top依旧指向的是NodeA的地址(实际上已经变为NodeC)，因此将top的值修改为了NodeX，这时栈结构如下：

```
                                   top
                                    |
   0x0014                           V
 | Node C | --> | Node B | --> |  Node X | --> ……
```

经过CAS操作后，top指针错误的指向了NodeX而不是NodeB。

----

**CAS机制的缺点**

- 无法支持代码块的原子操作（一次性需要更新多个变量的值）
- CPU开销大，自旋操作（不断进行比较和交换）！
- ABA问题（可以通过给内存中的值增加一个版本号来解决）

**参考**

- [什么是CAS机制？_qq_32998153的博客-CSDN博客](https://blog.csdn.net/qq_32998153/article/details/79529704)
- [比较并交换 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/比较并交换)
- [什么是ABA问题？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/23281499)

#### 2.3.2 Lock接口定义

JAVA SE 5之后新的接口和具体实现（之前一直使用`synchromized`来实现锁的功能），可以显示加锁和释放锁。缺少了`synchronized`隐式获取/释放锁的便捷性，无法直接声明在方法中；但是更加灵活如：

- **可中断地获取锁**（`sychronized`中如果一个线程在等待获取同步锁，则此时中断标志位会被修改，但是依旧阻塞等待同步锁，无法响应中断）
- **超时获取锁**
- **非阻塞获取锁**等

Lock的接口定义：

```java
public interface Lock {
	// 尝试加锁，如果加锁成功则返回，失败则阻塞等待(看具体接口实现类如何实现)
    void lock();

    // 可中断的获取锁，在所得获取过程中可以响应中断
    void lockInterruptibly() throws InterruptedException;

    // 非阻塞的获取锁，成功获取则返回true否则返回false
    boolean tryLock();

    // 超时的获取锁，当在超时时间内得到锁则return true、被中断则throws InterruptedException、超时时间结束则return false
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    // 释放锁(务必注意写在finally代码块中)
    void unlock();

    // 等待条件
    Condition newCondition();
}

```

Lock的使用方法：

```java
Lock lock = new ReentrantLock ();
lock.lock ();	// 如果lock返回则说明加锁成功代码继续执行
try {
    // ...
} finally {
    lock.unlock ();
}
```

`lock()/tryLock()`内部一般会调用AQS组件的`lock()/tryLock()`方法，`unlock()`调用AQS对应的`unlock()`方法。

#### 2.3.3 AQS(队列同步器)

队列同步器（AbstractQueueSynchronizer）是用来构建锁或者其他同步组件的基础框架，使用一个int型变量代表同步状态，通过内置的队列来完成等待获取资源的线程的排队工作。

> 同步器面向的是锁的实现者，利用同步器来实现各种锁的语义，**解耦锁的使用者和实现者**。
>
> Lock的接口实现基本都是通过聚合一个AQS的子类实现（使用静态内部类继承AQS，该内部类的对象作为Lock实现类的一个成员变量）来完成线程访问控制的。

**AQS <font color="blue">核心思想</font> 是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定/占用状态。如果被请求的共享资源被占用，将暂时将获取不到资源的线程加入到队列中，等待被唤醒后分配资源。**AQS 是将每条请求共享资源的线程封装成一个锁队列的一个结点（Node）来实现锁的分配。同步队列中的节点用来保存获取同步状态失败的**线程引用**、**等待状态**、**前驱节点**以及**后继节点**。

<font color="green">AQS使用一个int成员变量state来表示 **同步状态/锁**，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用 **CAS**对该同步状态进行原子操作实现对其值的修改。</font>

##### 独占式获取/释放锁的原理

获取同步状态时，调用 **`acquire`** 方法，维护一个同步队列：

- 使用 **`tryAcquire`** 方法（AQS子类需要实现该方法）安全地获取线程同步状态
  - 获取成功则直接返回（实现类trayAquire方法中会使用CAS修改锁状态，并将线程设置为AQS的有效工作线程）
  - 获取失败的线程会被构造成**同步节点**并通过 **`AQS.addWaiter`** 方法加入到同步队列的尾部（CAS自旋插入队尾直到成功）。
- 之后调用 **`acquireQueued`** 方法（如果前驱节点为头节点则尝试获取锁，否则（或者获取失败）则阻塞），<span style = "color:red">**被阻塞线程的唤醒主要依靠前驱节点的出队或被中断实现，移出队列或停止自旋的条件是前驱节点是头结点且成功获取了同步状态。**</span>

释放同步状态时，同步器将会执行以下步骤

- 调用 **`tryRelease`** 方法（AQS子类需要实现该方法）释放同步状态（不需要CAS，因为线程独占锁，不会产生竞争）
- 然后调用 **`unparkSuccessor`** 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。

```java
public abstract class AbstractQueuedSynchronizer {
    // ======获取同步状态=========
    public final void acquire(int arg) {
        // 1.1 tryAcquire()方法需要AQS子类来实现
        // 如果同步状态获取失败(加锁失败)
        // - 1.2 使用addWaiter(Node.EXCLUSIVE)进入AQS内置的同步队列中
        // - 1.3 使用acquireQueued()开始尝试自旋获取同步状态??
        // 如果再次获取同步状态失败(成功则直接返回)
        // - 1.4 开始阻塞，阻塞节点唤醒主要依靠：①前驱结点出队，②阻塞节点被中断??? selfInterrupt();
        if (!tryAcquire(arg) &&	
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))	
            selfInterrupt();	
    }  
    
    // ======释放同步状态=========
    public final boolean release(int arg) {
        if (tryRelease(arg)) {	// 1. tryRelease(arg)由AQS子类重写实现
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);	// 2. 唤醒后继节点
            return true;
        }
        return false;
    }
}
```

两者均采用模板方法的设计模式！

##### 共享式获取/释放锁的原理

和独占式获取/释放整体过程类似。

获取同步状态时，调用 **`acquireShared`** 方法，该方法调用 **`tryAcquireShared`** 方法尝试获取同步状态，返回值为 **int** 类型，返回值**不小于 0** 表示能获取同步状态。因此在共享式获取锁的自旋过程中，<span style = "color:red">**成功获取同步状态并退出自旋的条件就是该方法的返回值不小于0。**</span>

释放同步状态时，调用 **`releaseShared`** 方法，释放后会唤醒后续处于等待状态的节点。<span style = "color:red">**它和独占式的区别在于 `tryReleaseShared` 方法必须确保同步状态安全释放，通过循环 CAS 保证，因为释放同步状态的操作会同时来自多个线程。**</span>

```java
public abstract class AbstractQueuedSynchronizer {
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)	// tryAcquireShared()方法需要被子类重写(返回剩余共享锁的数量)
            doAcquireShared(arg);
    }    
    
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
}
```

#### 2.3.4 ReentrantLock原理

**`ReentranLock`就是一种利用AQS组件+CAS实现的可重入的锁。**重点是实现维护锁状态的方法（tryAquire/release方法）。

`ReentranLock `本身实现了`Lock`接口，内部类`NonfairSync`和`FairSync`类（父类是`Sync`继承了AQS），`ReentranLock`会根据传入参数的不同而构造公平、非公平锁（默认）。

**AQS对象内部**有一个核心的变量叫做<span style = "color:red">**state**</span>，是**int**类型的并且**加了volatile关键字**，代表了**加锁的状态**。初始状态下，这个state的值是0。

**AQS内部**还有一个关键变量 <span style = "color:red">**ExclusiveOwnerThread**</span>，用来**记录当前加锁的是哪个线程**，初始化状态下，这个变量是null。

##### 公平锁的实现

`FairSync`的lock方法：

- 直接进入 **acquire()** 方法（AQS模板方法）

- 在 `acquire()` 方法中先尝试调用 **tryAcquire() **方法来获取锁
  - 在 `tryAcquire()` 方法中，首先获取当前的state值:
    - 如果state值为0，<span style = "color:red">**先判断当前是否有正在排队的节点，**</span>如果没有前继节点才利用CAS获取锁，否则直接返回获取锁失败
    - 如果state不为0，判断占有锁的线程是否为当前线程，如果是的话，则令state++，即重入锁，否则直接返回获取锁失败
- 调用 `tryAcquire()` 方法获取锁失败，则将当前线程封装进Node节点，加入等待队列排队等待获取锁（AQS的模板流程）

```java
static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        acquire(1);	// AQS的模板方法,会调用tryAcquire(1)
    }

    /**
     * Fair version of tryAcquire.  Don't grant access unless
     * recursive call or no waiters or is first.
     */
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &&	// 判断是否需要排队(队列是否为空 ）)
                compareAndSetState(0, acquires)) {	// CAS设置占有该锁并设置当前占有锁的线程为自身
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {	// 【锁的重入】
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);	// 线程安全的，因为拥有当前同步状态的线程就是自身
            return true;
        }
        return false;
    }
}
```

##### 非公平锁的实现

非公平锁的`lock()`方法：

- 首先使用CAS设置同步状态为1，设置成功后将当前线程为该锁的独占线程，表示获取锁成功；失败则加入`acquire(1)`方法（AQS模板方法）
- `acquire(1) `方法先调用` tryAcquire()`方法尝试去获取锁
  - 先拿到当前 state 的值：
    - **如果 state 的值为0，**说明没有线程获得锁，则再次尝试使用CAS来尝试占有锁，占有成功，并设置当前线程为占有锁的线程，直接返回
    - **如果state不为0**，判断占有锁的线程是否为当前线程，如果是的话，则令 state++，即重入锁，否则直接返回获取锁失败
- 调用 `tryAcquire()` 方法获取锁失败，则将当前线程封装进Node节点，加入等待队列排队等待获取锁，之后获取锁的流程和公平锁一样。

```java
static final class NonfairSync extends Sync {
    final void lock() {
        // !!!首先进行一次CAS抢锁（公平锁没有这个步骤）
        if (compareAndSetState(0, 1))
            //如果设置成功，说明锁没被占用，设置当前线程为该锁的独占线程，表示获取锁成功
            setExclusiveOwnerThread(Thread.currentThread());
        else
            // 否则表明锁已经被占用, 调用acquire让线程去同步队列排队获取
            acquire(1);
    }
    
    // AbstractQueuedSynchronizer.acquire(int arg)
    // 以不可中断模式获取锁(独占模式)
    public final void acquire(int arg) {
        //如果线程尝试获取锁失败，会调用addWaiter方法将线程添加到同步队列。
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
    
    //尝试获取锁的方法
    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}

//非公平的获取锁
final boolean nonfairTryAcquire(int acquires) {
    // 获取当前线程
    final Thread current = Thread.currentThread();
    // 获取当前的同步状态
    int c = getState();
    // 如果当前同步状态为0，说明没有被占用
    if (c == 0) {
        // ！！！再次使用CAS抢锁(和公平锁不同，这里没有对阻塞队列进行判断)
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 否则，如果当前状态部为0，判断是否是当前线程占有的锁
    else if (current == getExclusiveOwnerThread()) {
        // 如果锁是被当前线程持有的, 就直接修改当前同步状态(重入锁)
        int nextc = c + acquires;
        
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        setState(nextc);
        return true;
    }
    // 如果持有锁的不是当前线程则返回失败标志
    return false;
}
// 在非公平锁的模式下一个线程在进入同步队列之前会尝试获取两遍锁，
// 如果获取成功则不进入同步队列排队，否则才进入同步队列排队。
```

##### 公平锁和非公平锁的区别

- 非公平锁在调用 **lock** 后，首先执行一次CAS抢锁，失败则和公平锁一样都会进入到 **tryAcquire()** 方法，在 tryAcquire() 方法中，如果发现锁这个时候被释放了（state == 0），**再次进行 CAS 抢锁**，但是**公平锁会判断等待队列是否有线程处于等待状态**，**如果有则不去抢锁，而是在后面排队**。

- 相对来说，**非公平锁会有更好的性能，因为它的吞吐量比较大**（线程释放锁后再次获取锁的概率很大，如果依旧可以成功获取则无需切换上下文）。当然，非公平锁让获取锁的时间变得更加不确定，**可能会导致在阻塞队列中的线程长期处于饥饿状态**。

### Synchronized，Volatile，Reentrantlock的不同使用场景及优缺点？

#### synchronized

**优点**

- 可以修饰方法（实例方法或静态方法均可）、代码块，使用灵活。
- 使用简单，自动加解锁。

**缺点**

- 开销大，因为涉及到线程切换，而JAVA线程和操作的原生线程是一一对应的，当阻塞一个线程是需要涉及到用户态和内核态的切换。JDK6之后有进行了各种**锁优化**，性能已经很好了！

**应用场景**

- 优化后的`sychronized`性能已经和`Reentranlock`差不多了，各类场景下可以优先使用`sychronized`。

####  volatile

当线程中读取volatile修饰的变量时，会跳过工作内存（Cache）直接读取主内存中的数据，修改volatile变量时也会理解写入主内存。同时该关键字可以禁止JVM进行指令重排序优化。

**优点**

- 可以保证解决内存可见性问题且效率高，不会带来线程上下文切换的开销（不涉及用户态和内核态的切换）。

**缺点**

- 只能修饰变量。

- 只能保证变量的可见性，不能保证对volatile变量操作的原子性。

**应用场景**

- 适合用于一个线程写，其它线程均读的情况。
- boolean变量，不涉及计数的情况

####  ReentrantLock

JDK层面实现（`sychronized`个`volatile`都是JVM层面实现的锁）的一种可重入锁，主要利用了各种`CAS`和`park`操作。

**优点**

- 可以修饰代码块。
- 支持非阻塞/超时获取锁、**支持公平和非公平锁**、阻塞等待时可以响应中断。
- 支持创建多个`Condition`。

**缺点**

- 加锁后需要手动解锁，未正确解锁可能造成死锁。
- 低版本JDK不支持而`sychronized`原生支持。

**应用场景**

- 在需要用到一些高级功能（非阻塞获取锁、公平锁等）时使用，其余时间尽量使用`sychronized`比较简单。

### JDK1.6后`synchronized`的优化

JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。

锁主要存在四种状态，依次是：**无锁状态**、**偏向锁状态**、**轻量级锁状态**、**重量级锁** 状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

![image-20210303234741529](images/image-20210303234741529.png)

#### 偏向锁

> 偏向锁是一种存在竞争时才加锁同步，无竞争则不同步的锁（每次都偏向一个线程）。

偏向锁的执行流程如下所示：

- 当线程检查对象头MarkWord中的线程ID是否指向自己，是则表示已经成功获取锁，否则尝试CAS修改对象头；
  - 如果CAS修改成功则将对象头中的线程ID设置为自己
  - 如果失败这说明存在竞争（已经有偏向锁了），撤销偏向锁

#### 轻量级锁

> 轻量级锁是基于**"对于绝大部分锁，在整个同步周期内都是不存在竞争的"**经验来实现的。所以加解锁尽量采用CAS操作，而不是重量级操作（如重量级锁用的系统的互斥量）。

#### 自旋和自适应自旋锁

>  一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。 为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋。
>
>  自旋达到一定次数则挂起线程，因为自旋是一个消耗CPU的操作。

#### 锁消除

> 虚拟机即使编译器在运行时，如果检测到那些共享数据**不可能存在竞争**，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。

#### 锁粗化

> 但如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，即使没有线程竞争也会导致不必要的性能消耗。因此如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把同步的范围扩展到整个操作序列的外部。
>
> eg:在while循环里面加解锁，自动变成在while循环外部加解锁。

#### 偏向/轻量级/重量级锁的对比

![image-20210304100854015](images/image-20210304100854015.png)

### 2.6 死锁

死锁示意图：

![线程死锁示意图 ](images/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d342f323031392d34254536254144254242254539253934253831312e706e67)

#### 死锁产生的条件

以下是操作系统中的定义：

1. **互斥条件**：该资源任意一个时刻只由一个线程占用。
2. **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. **不可剥夺条件**：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. **循环等待条件**:若干进程之间形成一种头尾相接的循环等待资源关系。

#### 避免死锁的方法

为了避免死锁，我们只要破坏产生死锁的四个条件中的其中一个就可以了。现在我们来挨个分析一下：

1. **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。
2. **破坏请求与保持条件** ：一次性申请所有的资源。
3. **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源（引入超时机制）。
4. **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

## 3. JAVA内存模型

### 3.1 JAVA内存模型基础知识

Java中的线程不直接和主内存交互，需要先和工作内存进行交互，具体如下所示：

![image-20210420232925949](images/image-20210420232925949.png)

<font color="blue">**工作内存是一个抽象概念，它主要包含了CPU的寄存器、L1/L2 Cahce等。**</font>

### 3.2 Happens-before规则

- 编译器生成的指令顺序可能和源代码中的顺序不一致（因为存在编译优化措施）；- 
- CPU可能采用乱序或并行的方式来执行指令； 
- 缓存可能会改变将写入变量提交到内存的顺序（批量写入可以减少IO次数），且保存在CPU本地的缓存对其它CPU是不可见的；

上述几个现象都会导致JAVA多线程同步问题！针对上述问题JMM给出了通用的happends-before规则。

**Happens-before规则是什么？**：在Java内存模型中，happens-before的意思是前一个操作的结果可以被后续操作（不管这些操作是否在同一线程中）获取。

**为什么需要Happens-before规则？**：JVM会对代码进行编译优化，会出现指令重排序情况**，为了避免编译优化对并发编程安全性的影响，**需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。

<font color="red">两个操作之间存在happens-before关系，并不意味着一定要按照happens-before原则制定的顺序来执行。如果重排序之后的执行结果与按照happens-before关系来执行的结果一致，那么这种重排序并不非法。</font>

> 举例：
>
> ```java
> i = 1;	// 操作A
> j = i;	// 操作B
> ```
>
> 如果操作A和B满足happends-before原则（比如给`i`加上`volatile`修饰），则可以保证`j=1`，否则无法保证。

在JMM（Java Memory Model）中，**如果一个操作执行的结果对另一个操作可见，那么这两个操作（可以在一个线程中也可以在不同线程中）之间必须满足happens-before规则**。

判断程序是否满足happens-before关系可以使用以下八条准则：

1. **程序次序规则**：如果程序中操作A在操作B之前执行，那么在**一个单独的线程**中操作A将在操作B之前执行；

   <font color="red">同一个线程中前面的所有写操作对后面的操作可见</font>

2. **管程锁定规则**：一个unlock操作先行发生于后面对 **同一个锁 **的lock操作；

   <font color="red">如果线程1解锁了monitor a，接着线程2锁定了a，那么，线程1解锁a之前的写操作都对线程2可见（线程1和线程2可以是同一个线程</font>

3. **volatile变量规则**：对一个变量的写操作先行发生于**后面**对这个变量的读操作；

   <font color="red">如果线程1写入了volatile变量v（临界资源），接着线程2读取了v，那么，线程1写入v及之前的写操作都对线程2可见</font>

4. **线程启动规则**：Thread 对象的 start() 方法先行发生于此线程的每一个动作；

5. **线程终结规则**：线程中所有的操作都先行发生于线程的终止检测，我们可以通过 Thread.join() 方法结束、Thread.isAlive() 的返回值手段检测到线程已经终止执行；

6. **线程中断规则**：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生；

7. **对象终结规则**：一个对象的初始化完成先行发生于它的 finalize() 方法的开始；

8. **传递性**：如果操作 A 先行发生于操作 B，而操作 B又先行发生于操作C，则可以得出操作A先行发生于操作C；

### 3.3 as-if-serial 规则

**as-if-serial是什么**：<span style = "color:red">不管怎么重排序，**单线程程序**的执行结果不能改变，编译器和处理器必须遵循 as-if-serial 语义。</span>

为了遵循 as-if-serial，编译器和处理器**不会对存在数据依赖关系的操作重排序**，因为这种重排序会改变执行结果。但是如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。

>  as-if-serial 规则把单线程程序保护起来，给程序员一种幻觉：单线程程序是按程序的顺序执行的。

### 3.4 as-if-serial 和 happens-before 的区别

as-if-serial 保证 **单线程** 程序的执行结果不变，happens-before 保证正确同步的 **多线程** 程序的执行结果不变。

这两种语义的目的都是为了在不改变程序执行结果的前提下**尽可能提高程序执行并行度**。

### 3.5 <font color="red">为什么`双重检查`的单例模式实现需要使用`volatile`关键字来修饰？</font>

首先看线程安全的带双重检查的单例模式代码：

```java
public class Singleton {
    private volatile static Singleton INSTANCE;	// 正确写法
    // private static Singleton INSTANCE;				// 错误写法
    
    private Singleton () {};
    
    public static getInstance () {
        if (INSTANCE == null) {						// Step1
            synchronized (Singleton.class) {		// Step2
                if (INSTANCE == null) {				// Step3
                    INSTANCE = new Singleton ();	// Step4
                }
            }
        }
        return INSTANCE;							// Step5
    }
}
```

其中`Step 4`就是问题的根源，因为该步骤并不是一个原子操作，具体可以分为如下三个步骤：

```java
memory = allocate();	// Step4.1 分配内存
ctorInstance(memory);	// Step4.2.初始化对象
INSTANCE = memory;		// Step4.3.将INSTANCE指向分配的内存地址
```

在 **错误写法** 的情况下，Step4.2和Step4.3可能被重排序（这是允许的，因为对于单线程内部来说，重排序后得执行结果和原始顺序的执行结果一致），此时假设有线程A和B在执行`getInstance()`方法，可能的执行时序表如下：

| 时间 | 线程A                                                        | 线程B                                                        |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| t1   | 执行Step4.1                                                  |                                                              |
| t2   | 执行Step4.3，此时Step4.2还未执行，即`INSTANCE`指向的对象还未初始化 |                                                              |
| t3   |                                                              | 执行Step1（此操作不需要获取同步锁，线程A获取的锁只锁住了对应的代码块并未锁住对象本身） |
| t4   |                                                              | 判定`INSTANCE`非空，后续开始访问该对象（<font color="red">异常访问，因为对象还未被正确初始化</font>） |
| t5   | 执行Step4.2，初始化`INSTANCE`指向的对象                      |                                                              |
| t6   | 访问`INSTANCE`对象（正常访问）                               |                                                              |

**解决方法**：

- 使用`volatile`关键字修饰`INSTANCE`，此时可以禁止编译器对Step4.2和Step4.3的重排序，让`INSTANCE`的变化对所有线程可见！
- 使用饿汉式写法，在类加载时立即初始化`INSTANCE`对象`private volatile static Singleton INSTANCE = new Singleton()`，此时由JVM来保证线程安全！

## 4. JAVA中的锁【已废弃，看第二节】

锁是为了多线程同步执行！

### 4.0 CAS机制

**CAS** (Compare And Swap) 是一种无锁实现`读-改-写`原子操作的机制。

一个线程需要对内存中的值进行修改（如果+1操作），在把修改后的值写入该内存前会首先比较之前记录的该内存中的值和当前读取的该内存中的值是否相同，相同则提交写入操作，否则再次尝试上述修改过程【自旋】！



```text
-------------------
|     |  10 |     |
-------------------
        V
已知内存地址V中当前存储的值为11.
线程A想对该值进行+1操作: a = V + 1; V = a;
线程B想对该值进行+2操作: b = V + 2; V = b;

- 当A在执行V = a = 11前线程被打断，CPU调度线程B进行执行，此时V内存储的值被更新为12;
- CPU再次调度线程A执行, 此时线程A对读取当前V中的值为12，和存储的旧值10不同, 于是写入操作失败
- 线程A再次尝试`a = V + 1; V = a`的操作，直到在提交更新(V = a)时V的旧值当前V值相同则提交！【自旋】
```

> CAS操作基于CPU提供的原子操作指令实现。对于Intel X86处理器，可通过在汇编指令前增加LOCK前缀来锁定系统总线，使系统总线在汇编指令执行时无法访问相应的内存地址。而各个编译器根据这个特点实现了各自的原子操作函数。
>
> **JAVA**中`sun.misc.Unsafe`提供了`compareAndSwap`系列函数。而`java.util.concurrent.atomic`中的原子类就使用了CAS机制。
>
> CAS执行结果要么成功要么失败，对于失败的情形下一般不断重试。或者放弃。

CAS的C代码实现：

```c
/**
 * @Brief CAS操作
 * @Param addr 要提交更新的内存地址
 * @Param old 该内存值记录的旧值
 * @Param new 要更新到该内存中的新值 
 */
int cas(long *addr, long old, long new)
{
    /* Executes atomically. */
    if(*addr != old)
        return 0;
    *addr = new;
    return 1;
}
```

**ABA问题**

ABA问题是无锁结构实现中常见的一种问题，可基本表述为：

1. 进程P1读取了一个数值A
2. P1被挂起(时间片耗尽、中断等)，进程P2开始执行
3. P2修改数值A为数值B，然后又修改回A
4. P1被唤醒，比较后发现数值A没有变化，程序继续执行。

对于P1来说，数值A未发生过改变，但实际上A已经被变化过了，继续使用可能会出现问题。在一般情况下，这似乎没有什么问题，但是在没有垃圾回收或者具有内存重用机制的环境中会出现严重的问题！试想如下情况：

```
   top
    |
    V   
  0x0014
| Node A | --> |  Node X | --> ……
```

有一个栈(先入后出)中有top和节点A，节点A目前位于栈顶top指针指向A。现在有一个进程P1想要pop一个节点，因此按照如下无锁操作进行

```
pop()
{
  do{
    ptr = top;            // ptr = top = NodeA
    next_prt = top->next; // next_ptr = NodeX
  } while(CAS(top, ptr, next_ptr) != true);
  return ptr;   
}
```

而进程P2在执行CAS操作之前打断了P1，并对栈进行了一系列的pop和push操作，使栈变为如下结构：

```
   top
    |
    V  
  0x0014
| Node C | --> | Node B | --> |  Node X | --> ……
```

进程P2首先pop出NodeA，之后又Push了两个NodeB和C，由于内存管理机制中广泛使用的内存重用机制，导致NodeC的地址与之前的NodeA一致。

这时P1又开始继续运行，在执行CAS操作时，由于top依旧指向的是NodeA的地址(实际上已经变为NodeC)，因此将top的值修改为了NodeX，这时栈结构如下：

```
                                   top
                                    |
   0x0014                           V
 | Node C | --> | Node B | --> |  Node X | --> ……
```

经过CAS操作后，top指针错误的指向了NodeX而不是NodeB。

----

**CAS机制的缺点**

- 无法支持代码块的原子操作（一次性需要更新多个变量的值）
- CPU开销大，自旋操作（不断进行比较和交换）！
- ABA问题（可以通过给内存中的值增加一个版本号来解决）

**参考**

- [什么是CAS机制？_qq_32998153的博客-CSDN博客](https://blog.csdn.net/qq_32998153/article/details/79529704)
- [比较并交换 - 维基百科，自由的百科全书 (wikipedia.org)](https://zh.wikipedia.org/wiki/比较并交换)
- [什么是ABA问题？ - 知乎 (zhihu.com)](https://www.zhihu.com/question/23281499)

### 4.1 Lock

JAVA SE 5之后新的接口和具体实现（之前一直使用`synchromized`来实现锁的功能），可以显示加锁和释放锁。缺少了`synchronized`隐式获取/释放锁的便捷性，无法直接声明在方法中；但是更加灵活如：

- 可中断地获取锁（`sychronized`中如果一个线程在等待获取同步锁，则此时中断标志位会被修改，但是依旧阻塞等待同步锁，无法响应中断）
- 超时获取锁
- 非阻塞获取锁等

```java
Lock lock = new ReentrantLock ();
lock.lock ();	// 如果lock返回则说明加锁成功代码继续执行
try {
    // ...
} finally {
    lock.unlock ();
}
```

Lock的接口定义：

```java
public interface Lock {
	// 尝试加锁，如果加锁成功则返回，失败则阻塞等待(看具体接口实现类如何实现)
    void lock();

    // 可中断的获取锁，在所得获取过程中可以响应中断
    void lockInterruptibly() throws InterruptedException;

    // 非阻塞的获取锁，成功获取则返回true否则返回false
    boolean tryLock();

    // 超时的获取锁，当在超时时间内得到锁则return true、被中断则throws InterruptedException、超时时间结束则return false
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    // 释放锁(务必注意写在finally代码块中)
    void unlock();

    // ??? 不懂
    Condition newCondition();
}

```

Lock的基本实现原理：

```java
public class XXXLock implements Lock  {
    private volatile int status = 0;	// 表示是否有线程获取了当前这把锁/获取到同步状态, volatile保证线程可见性
    
    public void lock () {
        // CAS + park()自旋
        while (!compareAndSet(0, 1)) {	// 尝试使用CAS操作去修改status(把0修改成1)
            park();	// 不能使用wait()因为他要配合sychronized使用, 不能使用sleep()因为睡眠时间不确定,park()内部调用了OS操作即UNSAFE.park()
        }
    }
    
    public void unlock () {
        status = 0;
        lockNotify();
    }
    
    private boolean compareAndSet (int expect, int new Value) {
        // CAS操作，修改status成功则返回true否则为false
    }
}

// ...其他类
    public static void park () {
        // 将线程加入到等待队列中
        parkQueue.add (Thread.currentThread());
        releaseCpu ();	// 线程阻塞在此处直到被unpark()唤醒
    }

	public static void lockNotify () {
        // 唤醒等待队列中的第一个线程
        Thread t = parkQueue.header();
        unpark(t);
    }
// ...
```

### 4.2 队列同步器 （AQS）

队列同步器（AbstractQueueSynchronizer）是用来构建锁或者其他同步组件的基础框架，使用一个int型变量代表同步状态，通过内置的队列来完成线程的排队工作。

同步器面向的是锁的实现者，利用同步器来实现各种锁的语义，**解耦锁的使用者和实现者**。

Lock的接口实现基本都是通过聚合一个AQS的子类实现（使用静态内部类继承AQS，该内部类的对象作为Lock实现类的一个成员变量）来完成线程访问控制的。

![image-20201104002431602](images/image-20201104002431602.png)

![image-20201104002457202](images/image-20201104002457202.png)

> AQS使用了**模板模式**！
>
> 如`acquire`方法中：
>
> ```java
> public final void acquire(int arg) {
>  // 尝试获取锁【由AQS子类定义语义】，获取失败则入队阻塞【由AQS完成】
>  if (!tryAcquire(arg) &&
>      acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
>      selfInterrupt();
> }
> 
> // tryAcquire需要子类重写
> protected boolean tryAcquire(int arg) {
>  throw new UnsupportedOperationException();
> }
> ```

> 主要涉及到：**park + 自旋  + CAS**
>
> AQS的队列头部有一个哑结点（包含一个空线程对象），后一个节点自旋一次（可能可以获取到锁）后park，再后面的节点直接`park()`
>
> 当前持有锁的线程并不会在队列中！队列的头部永远含有一个null Thread，后一个节点会把前一个节点的ws从0改成-1.

AQS中使用了双向链表来存储线程节点：

```text
class AbstractQueueSynchronizer {
	private transient volatile Node head;	// 队列头结点
    private transient volatile Node tail;	// 队列尾结点
    private volatile int waitStatus;	// 同步状态
    
    // --- 

    calss Node {
        Node pre;
        Node next;
        Thread t;
        volatile int waitStatus;	// 线程状态
        
        // ------- waitState定义 -------
        // 节点等待超时或被中断的线程，进入该状态后的结点将不会再变化（最终会被shouldParkAfterFailedAcquire()移出队列）
        static final int CANCELLED =  1;
        // 标识节点为等待唤醒的状态(已经/即将阻塞)，只要前驱节点释放同步锁，则将通知本节点unpark()，该状态由本节点的后继节点入队时被设置(每个node入队时ws为0, 同时设置pre.ws=SIGNAL)
        static final int SIGNAL    = -1;
        // 标识结点处于等待队列中，结点的线程等待在Condition上，当其他线程调用了Condition的signal方法后，CONDITION状态的结点将从等待队列转移到同步队列中，等待获取同步锁。
        static final int CONDITION = -2;
        // 与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态
        static final int PROPAGATE = -3;
        
        // 0 表示默认初始值，以上情况均不符合
    }
}
```

#### 4.2.1 独占式同步状态的获取与释放过程

独占式同一时间只允许一个线程占用同步锁/资源，其它线程只能阻塞等待。

##### 获取同步状态

`Lock`接口实现类的`lock()`方法会调用内部的AQS组件（Lock接口实现类中定义的内部类Sync——AQS的子类）的`acquire()`方法来获取独占锁。

```java
public abstract class AbstractQueuedSynchronizer {
    // ======获取同步状态=========
    public final void acquire(int arg) {
        // 1.1 tryAcquire()方法需要AQS子类来实现
        // 如果同步状态获取失败(加锁失败)
        // - 1.2 使用addWaiter(Node.EXCLUSIVE)进入AQS内置的同步队列中
        // - 1.3 使用acquireQueued()开始尝试自旋获取同步状态??
        // 如果再次获取同步状态失败(成功则直接返回)
        // - 1.4 开始阻塞，阻塞节点唤醒主要依靠：①前驱结点出队，②阻塞节点被中断??? selfInterrupt();
        if (!tryAcquire(arg) &&	
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))	
            selfInterrupt();	
    }   
    
    // 1.2 线程入队addWaiter()-----------------------------------
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // 若队列非空，则快速尝试一次CAS操作把自己添加到尾部
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);	// 1.2.1 CAS添加失败/队列为空 则使用enq方法入队，该方法内部使用==死循环+CAS==的方式来把节点插入队尾，把 多线程并发入队请求 变成 串行化入队请求
        return node;
    }
    
    // 1.2.1 初始化队列(如果队列为空的话)，将节点插入队尾----------
    private Node enq(final Node node) {
        // 无限循环CAS操作直到节点成功插入队尾
        for (;;) {
            Node t = tail;
            if (t == null) { // 如果此时队列为空，则插入一个哑结点/空节点到队首！！！当前线程对应的node并未入队！！！
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }
    
    // 1.3 尝试自旋获取同步状态acquireQueued()--------------------------
    // ###### 待完成！！！
	final boolean acquireQueued(final Node node, int arg) {
        boolean failed = true;
        try {
            // 处理interrupted标志位是为了本方法可以被acquireInterruptibly()复用
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();	// 获取前驱结点
                if (p == head && tryAcquire(arg)) {	// 如果前驱结点是头结点，则尝试获取锁【自旋】
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&	// 1.3.1 获取锁失败则阻塞
                    parkAndCheckInterrupt())	// 内部调用LockSupport.park(this)进行阻塞
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
    
    // 1.3.1 检查是否需要阻塞并修改前驱结点的waitState
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;
        if (ws > 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);	// 将所有前面已经被设置成CANCLE状态的节点从队列中移除
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
}
```

![image-20201108010515345](images/image-20201108010515345.png)

> 一般来说，shouldParkAfterFailedAcquire()会被调用两次，调用过程中可能可以成功获取到锁！

##### 释放同步状态

`Lock`接口实现类的`unlock()`方法首先会调用内部的AQS组件（Lock接口实现类中定义的内部类Sync——AQS的子类）的`release()`方法来释放独占锁。

```java
public abstract class AbstractQueuedSynchronizer {
    public final boolean release(int arg) {
        if (tryRelease(arg)) {	// 1. tryRelease(arg)由AQS子类重写实现
            Node h = head;
            if (h != null && h.waitStatus != 0)
                unparkSuccessor(h);	// 2. 唤醒后继节点
            return true;
        }
        return false;
    }
    
    // 2. 唤醒头结点的后继节点
    private void unparkSuccessor(Node node) {
        int ws = node.waitStatus;
        if (ws < 0)
            compareAndSetWaitStatus(node, ws, 0);

        // 如果直接后继节点为空或者ws为CANCEL(1)状态
        // 则从队尾向前寻找最接近当前node的非CANCEL节点s
        // 为什么不从前往后找
        Node s = node.next;
        if (s == null || s.waitStatus > 0) {
            s = null;
            for (Node t = tail; t != null && t != node; t = t.prev)
                if (t.waitStatus <= 0)
                    s = t;
        }
        if (s != null)
            LockSupport.unpark(s.thread);	// unpark() s节点
    }
}
```

#### 4.2.2 共享式同步状态的获取与释放过程

共享式运行同时有多个线程获取到同步资源/状态，如对一个文件进行读操作，可以是共享式的访问。

##### 获取同步状态

通过调用AQS组件的`acquireShared()`可以共享式获取同步状态。

```java
public abstract class AbstractQueuedSynchronizer {
    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) < 0)	// tryAcquireShared()方法需要被子类重写(返回剩余共享锁的数量)
            doAcquireShared(arg);
    }
    
    private void doAcquireShared(int arg) {
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {						// 如果前驱结点是头结点则自旋一次
                    int r = tryAcquireShared(arg);
                    if (r >= 0) {
                        setHeadAndPropagate(node, r);	// 成功获取同步锁，且还有剩余资源，唤醒后继节点来获取剩余资源！可能造成不必要的唤醒
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
}
```

##### 释放同步状态

```java
public abstract class AbstractQueuedSynchronizer {
    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) {
            doReleaseShared();
            return true;
        }
        return false;
    }
}
```

和独占式释放同步状态不同的是，这里的`tryReleaseShared()`可能被多个线程同时调用，所以子类重写该方法的时候一般需要使用**循环+CAS**的方式来处理。

### 4.3 ReentranLock 可重入锁

如果当前占有锁的线程可以再次占有该锁，那么可以说这个锁是可重入的！（`synchronized`支持隐式重入）。`ReentranLock`就是一种利用AQS组件（Sync 继承 AQS）实现的可重入的锁。其内部结构如下所示：

![image-20201112165335370](images/image-20201112165335370.png)

#### 公平/非公平锁

> 先对同步锁进行获取请求的线程一定先被满足，那么可以说这个锁是公平的，反之则是不公平的。

ReentranLock 本身实现了`Lock`接口，内部类`NonfairSync`和`FairSync`类（父类是`Sync`继承了AQS），`ReentranLock`会根据传入参数的不同而构造公平、非公平锁（默认）：

```java
abstract static class Sync extends AbstractQueuedSynchronizer {
    // ......    
    final boolean nonfairTryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {	// 【锁的重入】
            int nextc = c + acquires;
            if (nextc < 0) // overflow
                throw new Error("Maximum lock count exceeded");
            setState(nextc);
            return true;
        }
        return false;
    }
    
    protected final boolean tryRelease(int releases) {
        int c = getState() - releases;
        if (Thread.currentThread() != getExclusiveOwnerThread())
            throw new IllegalMonitorStateException();
        boolean free = false;
        if (c == 0) {	// 只有把同步状态全部释放后锁才完全释放【因为存在重入】
            free = true;
            setExclusiveOwnerThread(null);
        }
        setState(c);
        return free;
    }
    // ......
}

private final Sync sync;	

// 无参构造，默认构造非公平锁
public ReentrantLock() {
    sync = new NonfairSync();
}

// 带参构造
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
```

`NonfairSync`的lock方法: 直接开始进行CAS操作竞争锁，竞争失败则执行正常流程(入队、等待)。

```java
/**
 * Performs lock.  Try immediate barge, backing up to normal
 * acquire on failure.
 */
 static final class NonfairSync extends Sync {
     private static final long serialVersionUID = 7316153563782823691L;

     /**
      * Performs lock.  Try immediate barge, backing up to normal
      * acquire on failure.
      */
     final void lock() {
         if (compareAndSetState(0, 1))
             setExclusiveOwnerThread(Thread.currentThread());
         else
             acquire(1);	// AQS中的模板方法
     }

     protected final boolean tryAcquire(int acquires) {
         return nonfairTryAcquire(acquires);
     }
}
```

`FairSync`的lock方法：不执行CAS操作，直接入队等待。

```java
static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        acquire(1);	// AQS的方法
    }

    /**
     * Fair version of tryAcquire.  Don't grant access unless
     * recursive call or no waiters or is first.
     */
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &&	// 判断是否需要排队(队列是否为空 ）)
                compareAndSetState(0, acquires)) {	// CAS设置占有该锁并设置当前占有锁的线程为自身
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {	// 【锁的重入】
            int nextc = c + acquires;
            if (nextc < 0)
                throw new Error("Maximum lock count exceeded");
            setState(nextc);	// 线程安全的，因为拥有当前同步状态的线程就是自身
            return true;
        }
        return false;
    }
}
```

**说明**

- 公平锁可以保证线程以FIFO的顺序获取到同步状态，但是由此带来的是频繁的上下文切换（如果一个线程想多次获取同步状态的话）。
- 非公平锁容易造成线程"饥饿"，但是上下文切换少（如果一个线程在释放锁后想再次获取锁，那他连续成功获取的概率会很大，此时无需上下文切换）。
- `synchronized`是一种非公平锁。

### 4.4 ReentrantReadWriteLock读写锁

支持重入的读写锁。

#### 4.4.1 写锁的获取和释放

写锁时一种排它锁！

- 当线程**尝试获取写锁**时，如果已经有线程占用了读锁 **或** 占用锁（无论是读还是写）的线程不是自身，则本线程阻塞等待【在获取写锁时必须保证没有线程获取了读锁，否则将出现可见性问题：获取读锁的线程无法感知到写线程的操作】直到读锁被释放，本线程才能获取到写锁，一旦成功获取写锁，则其它读写线程的后续访问均被阻塞！

- 由于支持重入，所以写锁每次释放均减少相应的状态，直到变成0。

#### 4.4.2 读锁的获取和释放

读锁是一种共享锁！

- 当线程**尝试获取读锁**时，只要写状态为0(写锁没有被其它线程获取)，则当前线程可以成功获取到读锁，读状态增加相应值。
- 由于可能存在多个线程释放读锁，所以需要CAS来保证线程安全！

#### 4.4.3 锁降级的过程？

？？？

### 4.5 Condition接口

是`Lock`中用于实现类似`Object.wait()/notify()/notifyAll()`的机制，可以利用`Lock.newCondition()`得到一个`Condition`对象，然后调用Condition对象的`await()/signal()`方法来实现`wait()/notify()`机制，两者的编码范式也是非常类似的！

例如实现一个只能存储5个元素的线程安全的队列（参考`ArrayBlockingDeque`源码）：

```java
public class ConditionTest {
    public static void main(String[] args) {
        final BoundedQueue<Integer> queue = new BoundedQueue<>(3);
        for (int i = 0; i < 2; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        while (true) {
                            queue.add(1);
                            Thread.sleep(100);
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }

        for (int i = 0; i < 5; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        while (true) {
                            queue.remove();
                            Thread.sleep(100);
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }).start();
        }
    }
}

class BoundedQueue<T> {
    private Object[] item;	// 存储实际元素对象
    int count;	// 当前存储的元素总个数
    int addIndex; // 添加元素的下标值
    int removeIndex; // 删除元素的下标值
    Lock lock = new ReentrantLock();// 锁和对应的Condition对象
    Condition notEmpty = lock.newCondition();// 队列非空 Condition
    Condition notFull = lock.newCondition(); // 队列非满 Condition
    // 初始化边界队列
    public BoundedQueue(int maxSize) {
        item = new Object[maxSize];
    }
    // 添加一个元素
    public void add(T t) throws InterruptedException {
        lock.lock();
        try {
            // 如果队列已经满了则等待(使用while而不是if防止signalAll()产生早唤醒)
            // signalAll后所有在次等待的线程都被换新，其中有一个获取到锁，操作后轮到本线程获取到锁时可能条件已经改变了，
            while (item.length == count) {
                notFull.await();
            }

            System.out.println(Thread.currentThread().getName() + " add...");

            item[addIndex] = t;
            if (++addIndex == item.length) {
                addIndex = 0;
            }
            count++;
            notEmpty.signal();
        } finally {
            lock.unlock();
        }
    }

    public T remove() throws InterruptedException {
        lock.lock();
        try {
            // 队列为空, 等待
            while (count == 0) {
                notEmpty.await();
            }

            System.out.println(Thread.currentThread().getName() + " remove...");

            Object o = item[removeIndex];
            if (++removeIndex == item.length) {
                removeIndex = 0;
            }
            count--;
            notFull.signal();
            return (T) o;
        } finally {
            lock.unlock();
        }
    }
}

// ---- 输出打印 ----
/*
Thread-0 add...
Thread-1 remove...
Thread-0 add...
Thread-2 remove...
Thread-0 add...
Thread-2 remove...
Thread-0 add...
Thread-1 remove...
Thread-0 add...
Thread-2 remove...
*/
```

一个`Condition`对应一个等待队列，如果调用`await()`方法，则将该线程从同步队列加入到对应的等待队列的队尾**并释放锁**，如果调用`signal()`方法则将唤醒等待队列中第一个线程并将其加入同步队列中。

<img src="images/image-20201124180258431.png" alt="image-20201124180258431" style="zoom:50%;" />

### 4.X 重量级与轻量级锁

JAVA 1.6以前，`synchronized`是一种重量级锁，涉及到用户态和内核态的切换，十分耗费性能（代码可能在加了关键字后并没有涉及到高并发，但是又不得不加上以面对高并发的场景）！

> JAVA 1.6以前，`synchronized`是一种重量级锁，无论是否存在竞争执行，都涉及到用户态和内核态的切换，加锁和解锁都会调用OS的操作函数（mutex），十分耗费性能。
>
> 利用AQS组件实现的锁，在多个线程交替执行（并发但无竞争）的情况下，ReentranLock并没有使用park等系统相关的函数，在内部直接判断队列为空于是执行CAS操作、lock()直接返回，程序成功获取到锁继续执行。

重量锁：调用OS函数完成的阻塞/锁

轻量锁：不调用系统函数 JDK内部直接完成的锁？



## 5. 并发容器和框架

### 5.1 ConcurrentHashMap

#### 5.1.1 为什么要使用ConcurrentHashMap

- 在多线程执行PUT操作，且导致扩容时，HashMap可能形成循环链表，最终导致死循环：[hashmap的线程不安全体现在哪里？ - 多媒体光盘的回答 - 知乎](https://www.zhihu.com/question/28516433/answer/281307231)
- HashTable使用`sychronized`保证线程安全，但是效率低，所有操作均共用一把锁。

`HashMap`和`ConcurrentHashMap`的源码分析见 [10-HashMap and ConcurrentHashMap in JDK7_8.md](Java容器/markdown/10-HashMap%20and%20ConcurrentHashMap%20in%20JDK7_8.md)

### 5.2 ConcurrentLinkedDeque

并发安全的双端队列`Deque`接口的实现类。

`head`、`tail`指针不一定指向队列的头结点和尾节点！

使用CAS来保证线程安全，使用HOPS参数来减少CAS执行次数。

#### 5.2.1 入队

朴素的实现思路：



存在的问题：



实际的实现：

- 定位尾节点
- 更新尾节点为new Node（入队节点）
- 修改`tail`指向（如果需要的话）

![img](https://img2018.cnblogs.com/blog/1559627/201906/1559627-20190609222805699-1582840823.png)

```java
private void linkLast(E e) {
    checkNotNull(e);
    final Node<E> newNode = new Node<E>(e);

    restartFromTail:
    for (;;)
        for (Node<E> t = tail, p = t, q;;) {	// 获取tail节点t p
            if ((q = p.next) != null &&
                (q = (p = q).next) != null)	// p不是尾节点则将p后移, q为p.next = t.next.next, 判断p是否已经为尾节点(q==null)
                // Check for tail updates every other hop.
                // If p == q, we are sure to follow tail instead.
                p = (t != (t = tail)) ? t : q;	// 有其它线程改变了tail指向
            else if (p.prev == p) // NEXT_TERMINATOR
                continue restartFromTail;
            else {
                // p is last node
                newNode.lazySetPrev(p); // CAS piggyback
                if (p.casNext(null, newNode)) {
                    // Successful CAS is the linearization point
                    // for e to become an element of this deque,
                    // and for newNode to become "live".
                    if (p != t) // hop two nodes at a time	// 减少写volatile变量的次数(增加了读的次数)
                        casTail(t, newNode);  // Failure is OK.
                    return;
                }
                // Lost CAS race to another thread; re-read next
            }
        }
}
```



#### 5.2.2 出队

类似！

### 5.3 BlockingQueue 阻塞队列

队列满则`add()/offer()`方法阻塞直到有空间为止，队列空则`remove()/pool()`方法阻塞直到队列中有数据为止。

#### 5.3.1 ArrayBlockingQueue

由数组结构组成的有界阻塞队列。

通过`ReentranLock`及相应的`Condition`手动实现一个`ArrayBlockingDeque`:

```java
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author QiuYukang
 * @E-mail b612n@qq.com
 * @Date 2021/3/4 22:29
 */
public class ProductBuffer {
    private int maxNum; // 最大容量

    private List<Object> list;   // 当前产品

    private ReentrantLock lock; // 锁
    private Condition notFull;  // 可以继续生产
    private Condition notEmpty; // 可以继续消费

    public ProductBuffer(int maxNum) {
        this.maxNum = maxNum;
        list = new LinkedList<>();
        lock = new ReentrantLock();
        notFull = lock.newCondition();
        notEmpty = lock.newCondition();
    }

    public Object get() throws InterruptedException {
        Object obj = null;
        lock.lock();
        try {
            // 必须用while不能用if, 因为await()苏醒后可能产品已经被别的苏醒的线程先消费完了
            while (list.size() == 0) {
                System.out.println(Thread.currentThread().getId() + ":产品空了，等待生产中...");
                notEmpty.await();
            }
            obj = list.remove(0);
            notFull.signal();   // 通知可以继续生产
            System.out.println(Thread.currentThread().getId() + ":消费一件产品");
            return obj;
        } finally {
            lock.unlock();
        }
    }

    public void put(Object obj) throws InterruptedException {
        lock.lock();
        try {
            while (list.size() == maxNum) {
                System.out.println(Thread.currentThread().getId() + ":产品满了，等待消费中...");
                notFull.await();
            }
            list.add(obj);
            notEmpty.signal();
            System.out.println(Thread.currentThread().getId() + ":生产一件产品");
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        ProductBuffer factory = new ProductBuffer(3);
        Runnable producer = new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        factory.put(new Object());
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        Runnable comsumer = new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        factory.get();
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };

        new Thread(producer).start();
        new Thread(comsumer).start();
        new Thread(comsumer).start();
        new Thread(comsumer).start();
    }
}
```

各种阻塞队列会用在不同的线程池中！！！

#### 5.3.2 LinkedBlockingQueue

由链表结构组成的有界队列。

#### 5.3.3 PriorityBlockingQueue

支持优先级排序的无界队列。

。。。。。

### 5.4 Fork/Join框架

将任务进行拆分（`Fork`）多个子任务进行执行，子任务执行完毕后合并（`Join`）子任务的执行结果最终得到原始任务的结果，大致流程如下所示：

![image-20201230212625580](D:\学习\教研室\找工作相关\JavaNotes\images\image-20201230212625580.png)

以累加计算为例，计算`startNum~endNum`中数字的累加值，使用`fork/join`框架：

```java
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.Future;
import java.util.concurrent.RecursiveTask;

public class ForkJoinTest {
    public static void main(String[] args) {
        ForkJoinPool pool = new ForkJoinPool();
        CountTask task = new CountTask(1, 10000);
        Future<Integer> res = pool.submit(task);
        try {
            System.out.println(res.get());
        } catch (InterruptedException e) {
        } catch (ExecutionException e) {
        }
    }
}

class CountTask extends RecursiveTask<Integer> {
    private static final int THRESHOLD = 4;

    private int startNum;

    private int endNum;

    public CountTask(int startNum, int endNum) {
        this.startNum = startNum;
        this.endNum = endNum;
    }

    @Override
    protected Integer compute() {
        int sum = 0;

        // 检查是否要继续拆分子任务
        if (endNum - startNum < THRESHOLD) {
            // 直接计算
            for (int i = startNum; i <= endNum; i++) {
                sum += i;
            }
        } else {
            // 拆分子任务
            int midNum = startNum + (endNum - startNum) / 2;
            CountTask leftTask = new CountTask(startNum, midNum);
            CountTask rightTask = new CountTask(midNum + 1, endNum);
            leftTask.fork();
            rightTask.fork();
            sum = leftTask.join() + rightTask.join();	// 合并计算结果
        }

        return sum;
    }
}
```



## 6. Java中的13个原子操作类

基本上都是采用`CAS` + 自旋 的方式来实现原子操作的（调用`UNSAFE`类的各种操作）。如`AtomicInteger`中的`getAndIncrement()`方法实现：

```java
public final int getAndIncrement() {
    return unsafe.getAndAddInt(this, valueOffset, 1);
}

public final int getAndAddInt(Object var1, long var2, int var4) {
    int var5;
    do {
        var5 = this.getIntVolatile(var1, var2);	// 读取旧值
    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));	// CAS设置新值，失败则继续尝试CAS（自旋）
    return var5;
}
```



## 7. JAVA中的并发工具类

### 7.1 CountDownLatch 等待多线程完成



### 7.2 CyclicBarrier 同步屏障



### 7.3 Semaphore 控制并发线程数

类似共享锁的机制？

### 7.4 Exchange 线程间交换数据

两个线程到达同步点后可以交换彼此的数据。



## 8. JAVA中的线程池

线程池通过重复利用已经创建好的线程来完成计算任务，可以减少频繁创建和销毁线程带来的消耗，可以实现对资源的统一分配、调优和监控，提升对资源的利用率。

### 8.1 线程池的好处

- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

### 8.2 线程池的实现原理

#### 8.2.1 线程池的处理流程

线程池主要处理流程如下图所示：

![image-20210104102707688](images/image-20210104102707688.png)

- 使用者提交任务（Runable/Callable对象）到线程池中
- 线程池判断当前已经创建的 *核心线程数* 是否达到最大，未达到则继续创建新线程（即使现在有空闲线程），否则将尝试将任务加入到任务队列中等待处理
- 线程池判断任务队列是否已满，未满则将任务加入队列，否则继续尝试创建新线程
- 线程池判断当前线程数是否达到 *最大线程数*，未达到的创建新线程，否则将任务交给饱和策略进行处理

#### 8.2.2 线程池的任务执行流程

线程池任务执行流程如下图所示：

<注释-img src="images/image-20210104103637384.png" alt="image-20210104103637384" style="zoom: 50%;" />

![image-20210726161649305](images/image-20210726161649305.png)

> - 这是一种节点的生产者消费者模式，利用任务缓冲队列来实现任务提交者和任务执行者的解耦。
> - corePool内和corePoll外的线程从任务缓冲队列中获取任务的方式不一样，前者为阻塞式获取，后者为限时获取（获取不到则被销毁）。

以使用`execute()`方法向线程池提交任务为例：

```java
public void execute(Runnable command) {
    if (command == null)
        throw new NullPointerException();
    int c = ctl.get();	// ctl是一个AtomicInteger 类型的变量，代表当前工作线程状态(包含工作线程数和状态，用高低位和掩码进行区分)
    // 1.当前工作线程数少于核心线程数，继续创建新线程来处理任务
    if (workerCountOf(c) < corePoolSize) {	
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    // 2.当前工作线程数大于核心线程数，线程池无空闲线程，尝试将任务加入队列
    if (isRunning(c) && workQueue.offer(command)) {	
        int recheck = ctl.get();
        if (! isRunning(recheck) && remove(command))
            reject(command);	// ???
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 3.当前工作线程数大于核心线程数，线程池无空闲线程，队列已满，尝试增加线程数
    else if (!addWorker(command, false))	// 
        reject(command);	// 增加线程数失败(可能是达到最大线程数了)，执行饱和策略
}
```

#### 8.2.3 Worker线程

`addWork()`表示增加一个工作线程，该线程会对原始任务进行包装，在执行完任务后会自动从任务队列中继续取任务进行执行。

ThreadPoolExecutor回收工作线程，如果getTask结果为null则跳出循环(`runWorker`)，执行`processWorkerExit()`方法，销毁线程。getTask返回null分两种场景。

- 未调用`shutdown()` ，RUNNING状态下全部任务执行完成的场景

  - 线程数量大于`corePoolSize`，线程超时阻塞从任务队列获取任务，获取超时后CAS减少工作线程数，如果CAS成功，返回null，线程回收。否则进入下一次循环。当工作者线程数量小于等于corePoolSize，就可以一直阻塞了。 

- 调用`shutdown()` ，全部任务执行完成的场景。`shutdown() `会向所有线程发出中断信号，这时有两种可能。

  - 所有线程都在阻塞：中断唤醒，进入循环，都符合第一个if判断条件，都返回null，所有线程回收。

  - 任务还没有完全执行完：至少会有一条线程被回收。在`processWorkerExit(Worker w, boolean completedAbruptly)`方法里会调用`tryTerminate()`，向任意空闲线程发出中断信号。所有被阻塞的线程，最终都会被一个个唤醒，回收。

```java
final void runWorker(Worker w) {
    // 如果一直可以getTask成功的线程一直生存
	while (task != null || (task = getTask()) != null) {
        lock();
        task.run();
        unlock();
    }
}

private Runnable getTask() {
    boolean timedOut = false; // Did the last poll() time out?

    for (;;) {
        int c = ctl.get();
        int rs = runStateOf(c);

        // Check if queue empty only if necessary.
        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {
            decrementWorkerCount();
            return null;
        }

        int wc = workerCountOf(c);

        // Are workers subject to culling?
        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;

        if ((wc > maximumPoolSize || (timed && timedOut))
            && (wc > 1 || workQueue.isEmpty())) {
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }

        try {
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
            workQueue.take();
            if (r != null)
                return r;
            timedOut = true;
        } catch (InterruptedException retry) {
            timedOut = false;
        }
    }
}
```



#### 8.2.4 线程池生命周期

![image-20210726162006551](images/image-20210726162006551.png)

#### 8.2.5 包装线程池[`TtlExecutors`](https://github.com/alibaba/transmittable-thread-local/blob/master/src/main/java/com/alibaba/ttl/threadpool/TtlExecutors.java)

支持跨线程传递ThreadLocal数据。`JDK`的[`InheritableThreadLocal`](https://docs.oracle.com/javase/10/docs/api/java/lang/InheritableThreadLocal.html)类可以完成父线程到子线程的值传递。但对于使用线程池等会池化复用线程的执行组件的情况，线程由线程池创建好，并且线程是池化起来反复使用的；这时父子线程关系的`ThreadLocal`值传递已经没有意义，应用需要的实际上是把 **任务提交给线程池时**的`ThreadLocal`值传递到 **任务执行时**。

基本原理：对Runnable/Callable对象进行重写，在创建实际对象前将ThreadLocal中的数据复制到Runnable对象中，任务执行完毕则清空ThreadLocal数据。

### 8.3 线程池的使用

#### 8.3.1 创建线程池/线程池七大参数

一般使用`ThreadPollExecutor`来创建线程池，其构造函数如下所示：

```java
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {}
```

线程池主要有 **<font color="red">七大参数</font>**：

- **`corePoolSize` :** 核心线程数线程数定义了线程池的基本大小。当提交一个新任务, 线程池会创建一个新的线程(即使已经有空闲线程)，直到已创建线程数达到基本大小则不再创建(如果此时提交新任务时没有空闲线程, 则将新任务存储到队列中)。
- **`maximumPoolSize` :** 线程池的最大线程数。当提交新任务时没有空闲线程且任务队列已满，则继续创建新线程直到达到最大值。
- **`workQueue`:** 任务队列。当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。

- `keepAliveTime`:当线程池中的线程数量大于 `corePoolSize` 的时候，如果这时没有新的任务提交，核心线程外的空闲线程不会立即销毁，而是会等待，直到等待的时间超过了 `keepAliveTime`才会被回收销毁。

- `unit` : `keepAliveTime` 参数的时间单位。

- `threadFactory` :executor 创建新线程的时候会用到，如使用开源框架提供的线程工厂可以快速给创建的线程设置更有意义的名字等。

- `handler` :饱和策略。当线程池已经关闭，或任务队列满且线程数量达到最大时，无法处理提交的新任务，则调用饱和策略进行处理（默认策略为`AbortPolicy`表示无法处理新任务抛出异常，JDK还提供了`CallerRunsPolicy`、`DiscardOldestPolicy`、`DiscardPolicy`已有策略）。

#### 8.3.2 执行/向线程池提交任务

可以调用线程池的`execute()`和`submit()`方法来向线程池提交任务。

- `execute()`只需要传入一个实现`Runnable`接口的对象，无返回值所以无法判断线程的执行情况。

    ```java
    public void execute(Runnable command) {}
    ```

- `submit()`同样是传入类似的参数并返回`Future`类型的参数，可通过其`get()`方法阻塞获取返回值。

  ```java
  // 该方法的实现在ThreadPoolExecutor的父类AbstractExecutorService中定义
  public Future<?> submit(Runnable task) {}	// Runnable接口的run方法无返回值，线程池内部的FutureTask会利用适配器模式(RunnableAdapter)将其转成Callable对象来运行(此时并没有真正的返回值)
  public Future<?> submit(Callable task) {}	// 传入Callable对象则可真正实现获取返回值
  ```

  示例见 `1.2.3 实现Callable接口`部分。

#### 8.3.3 销毁线程池

可以使用`shutdown()`或`shutdownNow()`方法来关闭线程池，前者会等待在在执行的任务执行完成后再关闭，后者会立即关闭！可使用`isShutdown()`来判断线程池是否被调用了关闭方法，使用`isTerminated()`来判断线程池是否完成关闭。

#### 8.3.4 完整示例

```java
import java.util.Date;
import java.util.Random;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadPoolExecutorDemo {
    private static final int CORE_POOL_SIZE = 5;

    private static final int MAX_PORE_SIZE = 10;

    private static final int QUEUE_CAPACITY = 4;

    private static final long KEEP_ALIVE_TIME = 1L;

    public static void main(String[] args) throws InterruptedException {
        ThreadPoolExecutor threadPool = new ThreadPoolExecutor(
                CORE_POOL_SIZE,
                MAX_PORE_SIZE,
                KEEP_ALIVE_TIME,
                TimeUnit.SECONDS,
                new ArrayBlockingQueue<>(QUEUE_CAPACITY),
                new ThreadPoolExecutor.CallerRunsPolicy()
        );
        for (int i = 0; i < 10; i++) {
            threadPool.execute(new MyTask());
        }
        threadPool.shutdown();  // 关闭线程池(未执行完的任务会继续执行， 不再接受新的任务)
        while (!threadPool.isTerminated()) {
            Thread.sleep(100);
        }
        System.out.println(new Date() + " finish!");
    }
}

class MyTask implements Runnable {
    @Override
    public void run() {
        System.out.println(new Date() + " " + Thread.currentThread().getName() + " start...");
        process(new Random().nextInt(1500));
        System.out.println(new Date() + " " + Thread.currentThread().getName() + " finish...");
    }

    /**
     * 模拟计算任务
     * @param time 任务需要执行的时间长短
     */
    private void process(long time) {
        try {
            Thread.sleep(time);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

#### 8.3.5 ThreadPollExcutor的四大饱和/拒绝策略

先线程池提交任务时，如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，则需要执行拒绝/饱和策略来处理新任务:

- **`ThreadPoolExecutor.AbortPolicy`**：抛出 `RejectedExecutionException`来**拒绝**新任务的处理。
- **`ThreadPoolExecutor.CallerRunsPolicy`**：只用**调用者所在线程来执行任务**，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。另外，这个策略喜欢增加队列容量。如果您的应用程序可以承受此延迟并且你不能任务丢弃任何一个任务请求的话，你可以选择这个策略。
- **`ThreadPoolExecutor.DiscardPolicy`：** 不处理新任务，直接**丢弃**掉。
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将**丢弃最早的未处理**的任务请求。

#### 8.3.6 线程池大小设置原则

线程池如果设置的**太小**，如果有大量任务涌入，将导致大量**任务堆积**在任务队列中，最终可能导致OOM。

线程池如果设置的**太大**，大量线程可能会征用数量有限的CPU，大量的**上下文切换**增加线程执行开销，影响任务执行效率。

线程池大小的选取原则（假设CPU数为N）：

- <span style = "color:red">**CPU 密集型任务(N+1)：**</span> 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数**多出来的一个线程是为了防止线程偶发的缺页中断**，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- <span style = "color:red">**I/O 密集型任务(2N)：** </span>这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。

> 一般来说，核心线程数和最大线程数设置为一样！提高响应速度！

#### 8.3.7 线程池参数设置原则

为了说明合理设置的条件，我们首先确定有以下几个相关参数：

- `tasks`，程序每秒需要处理的最大任务数量（类似QPS eg：假设系统每秒任务数为100~1000）
- `tasktime`，单线程处理一个任务所需要的时间（eg：每个任务耗时0.1秒）
- `responsetime`，系统允许任务最大的响应时间（eg：每个任务的响应时间不得超过2秒）

则可以确定如下参数：

- 单个线程处理的最大任务数量`maxTasks`：`1 / tasktime`
- 线程池`corePoolSize`线程数：`tasks `* `tasktime`
- 任务队列`queueCapacity`：`(corePoolSize/tasktime) * responsetime`，即核心线程最大处理能力 * 系统运行的任务最大响应时延
- 线程池：`maxPoolSize = (max(tasks)- queueCapacity)/(1/taskTime)`

## 9. Executor框架

可以参考 [深入理解Java线程池：ThreadPoolExecutor | Idea Buffer](http://www.ideabuffer.cn/2017/04/04/深入理解Java线程池：ThreadPoolExecutor/)

### 9.1 整体框架图

#### 9.1.1 Executor框架类与接口

![QQ20170331-004227.png](images/QQ20170331-004227.png)

线程池有两个实现类：`ThreadPollExecutor`和`ScheduleThreadPoolExecutor`。

`ThreadPoolExecutor`实现的顶层接口是`Executor`，顶层接口`Executor`提供了一种思想：**将任务提交和任务执行进行解耦**。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供`Runnable`对象，将任务的运行逻辑提交到执行器(`Executor`)中，由`Executor`框架完成线程的调配和任务的执行部分。`ExecutorService`接口增加了一些能力：

- 扩充执行任务的能力，补充可以为一个或一批异步任务生成`Future`的方法；
- 提供了管控线程池的方法，比如停止线程池的运行，查询线程池的状态等。

`AbstractExecutorService`则是上层的抽象类，将执行任务的流程串联了起来(相当于模板)，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类`ThreadPoolExecutor`实现最复杂的运行部分，`ThreadPoolExecutor`将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。

#### 9.1.2 Executor框架的使用

![Executor 框架的使用示意图](https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/Executor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

主线程往线程池提交`Runable/Callable`对象（任务），可通过`FutureTask`对象的`get()`方法来获取线程的执行结果。

### 9.2 ThreadPoolExecutor

运行原理：

![image-20210618153323650](images/image-20210618153323650.png)

线程池在内部实际上构建了一个生产者消费者模型，**将线程和任务两者解耦**，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：

- 直接申请线程执行该任务；
- 缓冲到队列中等待线程执行； 
- 拒绝该任务。

线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。

通常使用`Executors`工具类创建不同的`ThreadPoolExecutor`线程池（为使用者简化线程池七大参数的配置）。

#### 9.2.1 FixThreadPool

使用无界队列（LinkedBlockingQueue）、maxPoolSize无效（因为任务队列不可能满）、keepAliveTime无效（因为总线程数不会超过核心线程数）、在线程池未关闭的情况下不会执行饱和策略（因为不可能饱和）。

```java
public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) {
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue<Runnable>(),
                                  threadFactory);
}
```

> 运行中的 `FixedThreadPool`（未执行 `shutdown()`或 `shutdownNow()`）不会拒绝任务，在任务比较多的时候会导致 OOM（内存溢出）。

#### 9.2.2 SingleThreadPool

只有一个`Worker`线程，其余同`FixThreadPool`。

```java
public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) {
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue<Runnable>(),
                                threadFactory));
}
```

#### 9.9.3 CacheThreadPool

根据需要创建新线程的线程池。

```
    /**
     * 创建一个线程池，根据需要创建新线程，但会在先前构建的线程可用时重用它。
     */
    public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>(),
                                      threadFactory);
    }
    public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
```

`CachedThreadPool` 的`corePoolSize` 被设置为空（0），`maximumPoolSize`被设置为 `Integer.MAX.VALUE`，即它是无界的；使用不存储元素的阻塞队列`SynchronousQueue`，一个任务提交必须有一个空闲线程来执行该任务，否则无法提交新任务到队列中；这也就意味着如果主线程提交任务的速度高于 `maximumPool` 中线程处理任务的速度时，`CachedThreadPool` 会不断创建新的线程。极端情况下，这样会导致耗尽 cpu 和内存资源。

> `CachedThreadPool`允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。

## 10. 面试题整理

### 10.1 什么是内存可见性问题？

每个Java线程都有一个对应的工作内存（Cache），工作内存（缓存共享变量）和主内存（存储共享变量）打交道。Cache中的缓存变量值可能没有及时刷新，而对应的变量已经被其它线程修改并刷新到主内存中了，所以导致两个线程在某一时刻读到的变量值不一致（说白了就是Cache和主存中的数据不一致）。

![image-20210226181655874](images/image-20210226181655874.png)

### 10.3 启动线程为什么要调用start()而不直接调用run()

`start()`方法中会调用`start0()`方法，这是一个JNI，会控制操作系统分配线程资源，`start0()`中会自动调用`run()`方法；如果直接调用`run()`则只是主程序对一个对象的方法的普通调用，并没有启动多线程。

![在这里插入图片描述](images/20210118173547289.png)

### 10.6 ThreadPollExcutor是怎么保证核心线程不被销毁的？



### 10.7 Java多线程存在线程安全的根本原因？

- **共享变量的可见性**：每个JAVA线程都有一个工作内存（缓存），线程直接读写工作内存，工作内存和主内存打交道；当写入工作内存的共享变量没有及时刷新到主内存，或当前工作内存中的数据是以前缓存的数据而不是当前主内存中最新的数据；会导致多个线程读取的同一共享变量的值是不一致的。
- **线程执行操作的原子性**：对共享变量的修改操作可能被其它线程打断，其它线程也可能对这个变量进行操作，所以导致线程不安全。

> 使用`volatile`关键字保证共享变量的可见性（无法保证原子性），使用`synchronized`或者`Lock`保证执行代码块/方法的原子性。

### 10.8 Java 线程池里的 arrayblockingqueue 与 linkedblockingqueue 的使用场景和区别？

两者都实现了BlockingQueue接口（可阻塞队列）；

内部都是使用ReentrantLock和Condition来保证生产和消费的同步；

当队列为空，消费者线程（执行任务的线程）被阻塞；当队列装满，生产者线程（提交任务的线程）被阻塞；

**ArrayBlockingQueue**

- 底层结构：使用数组，大小正在创建是就固定了；
- 锁：读写共用一把锁`lock`；
- 使用场景：FIFO，支持公平（降低吞吐量为代价）和非公平。

**LinkedBlockingQueue**

- 底层结构：使用单链表，在创建时可指定大小，否则为`Integer.MAX_VALUE`；
- 锁：读写分别有一把锁`takeLock`和`putLock`；
- 使用场景：非公平，适合在高并发的情况下使用（读写可以并行），可以提升吞吐量，但是可能OOM，任务延迟高。

### 10.9 手写生产者消费者模式？

#### synchronized+wait()+notify()版

```java
public class SharedData {
    private int maxNum;
    private Object[] list;
    private int size, putIndex, getIndex;

    public SharedData(int maxNum) {
        list = new Object[maxNum];
        this.maxNum = maxNum;
    }

    public synchronized Object get() throws InterruptedException {
        while (size == 0) {	// 必须使用while防止早唤醒
            this.wait();	// 默认使用当前实例化对象作为锁
        }
        size--;
        Object obj = list[getIndex];
        if (++getIndex == maxNum) {
            getIndex = 0;
        }
        this.notifyAll();
        return obj;
    }

    public synchronized void put(Object obj) throws InterruptedException {
        while (size == maxNum) {
            this.wait();
        }
        size++;
        list[putIndex] = obj;
        if (++putIndex == maxNum) {
            putIndex = 0;
        }
        this.notifyAll();
    }
}
```



#### Lock+Condition版

- 注意`Condition.await()`条件判断一定要用`while()`不能用`if()`，因为`await()`被唤醒并且执行后面的代码时，可能其它被唤醒的线程比当前线程先拿到锁并且先执行了后面的代码（可能已经修改了判断条件中的变量了），所以`await()`唤醒后还需要继续进行一次判断。

```java
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @Author QiuYukang
 * @E-mail b612n@qq.com
 * @Date 2021/3/4 22:29
 */
public class ProductBuffer {
    private int maxNum; // 最大容量

    private List<Object> list;   // 当前产品

    private ReentrantLock lock; // 锁
    private Condition notFull;  // 可以继续生产
    private Condition notEmpty; // 可以继续消费

    public ProductBuffer(int maxNum) {
        this.maxNum = maxNum;
        list = new LinkedList<>();
        lock = new ReentrantLock();
        notFull = lock.newCondition();
        notEmpty = lock.newCondition();
    }

    public Object get() throws InterruptedException {
        Object obj = null;
        lock.lock();
        try {
            // 必须用while不能用if, 因为await()苏醒后可能产品已经被别的苏醒的线程先消费完了
            while (list.size() == 0) {
                System.out.println(Thread.currentThread().getId() + ":产品空了，等待生产中...");
                notEmpty.await();
            }
            obj = list.remove(0);
            notFull.signal();   // 通知可以继续生产
            System.out.println(Thread.currentThread().getId() + ":消费一件产品");
            return obj;
        } finally {
            lock.unlock();
        }
    }

    public void put(Object obj) throws InterruptedException {
        lock.lock();
        try {
            while (list.size() == maxNum) {
                System.out.println(Thread.currentThread().getId() + ":产品满了，等待消费中...");
                notFull.await();
            }
            list.add(obj);
            notEmpty.signal();
            System.out.println(Thread.currentThread().getId() + ":生产一件产品");
        } finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        ProductBuffer factory = new ProductBuffer(3);
        Runnable producer = new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        factory.put(new Object());
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };
        Runnable comsumer = new Runnable() {
            @Override
            public void run() {
                while (true) {
                    try {
                        factory.get();
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        };

        new Thread(producer).start();
        new Thread(comsumer).start();
        new Thread(comsumer).start();
        new Thread(comsumer).start();
    }
}
```

### 10.10 集合类中的 List 和 Map 的线程安全版本是什么，如何保证线程安全的？

#### CopyOnWriteArrayList

`CopyOnWriteArrayList` 类的所有可变操作（add，set 等等）都是通过**创建底层数组的新副本**来实现的。当 List 需要被修改的时候，我并不修改原有内容，**而是对原有数据进行一次复制**，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。

```java
// CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();	// 加锁
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);	// 复制数组
        newElements[len] = e;
        setArray(newElements);	// 修改引用到新数组
        return true;
    } finally {
        lock.unlock();
    }
}
```

**读取操作没有任何同步控制和锁操作**，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全（可能读到的不是最新的数据，只保证弱一致性）。

```java
// 读操作完全不用锁
public E get(int index) {
    return get(getArray(), index);
}

private E get(Object[] a, int index) {
    return (E) a[index];
}
```

> Linux利用fork创建多进程也是类似的COW机制。

#### ConcurrentHashMap

JDK1.7以前采用分段锁（每个Segment一个锁，一个Segment中有一个数组+链表的结构）；1.8时改为数组+链表/红黑树，直接锁定整个链表/红黑树（一个数组元素）。